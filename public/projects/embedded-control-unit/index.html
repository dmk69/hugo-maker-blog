<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒ | Automation & Industrial Control Technician</title><meta name=keywords content="STM32,Cè¯­è¨€,Modbus,ä¼ æ„Ÿå™¨,åµŒå…¥å¼æ§åˆ¶"><meta name=description content='ğŸ”§ é¡¹ç›®æ¦‚è¿°
è¿™æ˜¯ä¸€ä¸ªåŸºäºSTM32F4ç³»åˆ—å¾®æ§åˆ¶å™¨çš„æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒï¼Œä¸“é—¨ç”¨äºå·¥ä¸šç°åœºçš„æ•°æ®é‡‡é›†ã€è®¾å¤‡æ§åˆ¶å’Œæ•°æ®é€šä¿¡ã€‚è¯¥æ§åˆ¶å•å…ƒé›†æˆäº†å¤šç§å·¥ä¸šä¼ æ„Ÿå™¨ï¼Œæ”¯æŒModbus RTU/TCPé€šä¿¡åè®®ï¼Œå¯ä½œä¸ºPLCç³»ç»Ÿçš„è¡¥å……æ§åˆ¶å™¨æˆ–ç‹¬ç«‹çš„ç›‘æ§èŠ‚ç‚¹ä½¿ç”¨ã€‚
ğŸ¯ é¡¹ç›®ç›®æ ‡

å®ç°å¤šä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†å’Œé¢„å¤„ç†
æä¾›æœ¬åœ°æ§åˆ¶å’Œä¿æŠ¤åŠŸèƒ½
æ”¯æŒModbuså·¥ä¸šé€šä¿¡åè®®
å…·å¤‡æ•°æ®è®°å½•å’Œæ•…éšœè¯Šæ–­èƒ½åŠ›
æ»¡è¶³å·¥ä¸šç¯å¢ƒçš„å¯é æ€§è¦æ±‚

ğŸ”§ ç¡¬ä»¶æ¶æ„
STM32æ§åˆ¶æ¿è®¾è®¡
ç¡¬ä»¶é…ç½®:
ä¸»æ§åˆ¶å™¨:
â”œâ”€â”€ STM32F407VGT6 (ARM Cortex-M4, 168MHz)
â”œâ”€â”€ 1MB Flash, 192KB RAM
â”œâ”€â”€ 3Ã—UART (é€šä¿¡æ¥å£)
â”œâ”€â”€ 2Ã—I2C (ä¼ æ„Ÿå™¨æ‰©å±•)
â”œâ”€â”€ 3Ã—SPI (é«˜é€Ÿæ•°æ®æ¥å£)
â”œâ”€â”€ 16Ã—12ä½ADC (æ¨¡æ‹Ÿé‡é‡‡é›†)
â””â”€â”€ 2Ã—12ä½DAC (æ¨¡æ‹Ÿé‡è¾“å‡º)

ç”µæºç®¡ç†:
â”œâ”€â”€ 24V DCå·¥ä¸šç”µæºè¾“å…¥
â”œâ”€â”€ 5V/3.3V DC-DCè½¬æ¢å™¨
â”œâ”€â”€ ç”µæºæ»¤æ³¢å’Œä¿æŠ¤ç”µè·¯
â”œâ”€â”€ å¤‡ç”¨ç”µæ±  (RTCå’Œæ•°æ®ä¿æŒ)
â””â”€â”€ çœ‹é—¨ç‹—å®šæ—¶å™¨

é€šä¿¡æ¥å£:
â”œâ”€â”€ RS485æ¥å£ (Modbus RTU)
â”œâ”€â”€ Ethernetæ¥å£ (Modbus TCP)
â”œâ”€â”€ USBæ¥å£ (è°ƒè¯•å’Œé…ç½®)
â”œâ”€â”€ CANæ€»çº¿æ¥å£ (è®¾å¤‡äº’è”)
â””â”€â”€ WiFiæ¨¡å— (å¯é€‰æ— çº¿é€šä¿¡)
ä¼ æ„Ÿå™¨æ¥å£ç”µè·¯
ä¼ æ„Ÿå™¨è¿æ¥:
â”œâ”€â”€ æ¸©åº¦ä¼ æ„Ÿå™¨ (PT100)
â”‚   â”œâ”€â”€ æ’æµæºæ¿€åŠ±ç”µè·¯
â”‚   â”œâ”€â”€ ä¿¡å·æ”¾å¤§å’Œæ»¤æ³¢
â”‚   â””â”€â”€ å†·ç«¯è¡¥å¿
â”œâ”€â”€ å‹åŠ›ä¼ æ„Ÿå™¨ (4-20mA)
â”‚   â”œâ”€â”€ ç²¾å¯†ç”µé˜»é‡‡æ ·
â”‚   â”œâ”€â”€ è¿‡å‹ä¿æŠ¤
â”‚   â””â”€â”€ ä¿¡å·éš”ç¦»
â”œâ”€â”€ æµé‡è®¡ (è„‰å†²è¾“å‡º)
â”‚   â”œâ”€â”€ å…‰ç”µéš”ç¦»è¾“å…¥
â”‚   â”œâ”€â”€ é¢‘ç‡æµ‹é‡ç”µè·¯
â”‚   â””â”€â”€ æŠ—å¹²æ‰°æ»¤æ³¢
â””â”€â”€ æŒ¯åŠ¨ä¼ æ„Ÿå™¨ (IEPE)
    â”œâ”€â”€ æ’æµæºä¾›ç”µ
    â”œâ”€â”€ ACä¿¡å·æ”¾å¤§
    â””â”€â”€ RMSè½¬æ¢ç”µè·¯
ğŸ’» è½¯ä»¶æ¶æ„
ä¸»ç¨‹åºæ¡†æ¶
/**
 * @file main.c
 * @brief æ™ºèƒ½æ§åˆ¶å•å…ƒä¸»ç¨‹åº
 * @author Automation Technician
 * @date 2025-11-12
 */

#include "main.h"
#include "sensor_manager.h"
#include "modbus_server.h"
#include "data_logger.h"
#include "watchdog.h"
#include "system_config.h"

/* å…¨å±€å˜é‡å®šä¹‰ */
SystemStatus_t g_systemStatus;
SensorData_t g_sensorData;
ModbusRegisters_t g_modbusRegisters;
uint32_t g_systemTick = 0;

/* å‡½æ•°å£°æ˜ */
static void SystemClock_Config(void);
static void GPIO_Init(void);
static void Peripherals_Init(void);
static void Task_SensorAcquisition(void);
static void Task_DataProcessing(void);
static void Task_Communication(void);
static void Task_SystemMonitoring(void);

/**
 * @brief ä¸»å‡½æ•°
 */
int main(void)
{
    /* ç³»ç»Ÿåˆå§‹åŒ– */
    HAL_Init();
    SystemClock_Config();
    GPIO_Init();
    Peripherals_Init();

    /* å¤–è®¾åˆå§‹åŒ– */
    SensorManager_Init();
    ModbusServer_Init();
    DataLogger_Init();
    Watchdog_Init();

    /* ç³»ç»ŸçŠ¶æ€åˆå§‹åŒ– */
    g_systemStatus.mode = MODE_AUTO;
    g_systemStatus.error_code = ERROR_NONE;
    g_systemStatus.uptime = 0;

    /* ä¸»å¾ªç¯ */
    while (1)
    {
        g_systemTick = HAL_GetTick();

        /* ä»»åŠ¡è°ƒåº¦ */
        Task_SensorAcquisition();    // 100mså‘¨æœŸ
        Task_DataProcessing();       // 500mså‘¨æœŸ
        Task_Communication();        // å®æ—¶å¤„ç†
        Task_SystemMonitoring();     // 1000mså‘¨æœŸ

        /* å–‚ç‹— */
        Watchdog_Refresh();

        /* ä½åŠŸè€—å¤„ç† */
        if (g_systemStatus.mode == MODE_SLEEP) {
            __WFI();
        }
    }
}

/**
 * @brief ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†ä»»åŠ¡
 */
static void Task_SensorAcquisition(void)
{
    static uint32_t lastAcquisitionTime = 0;

    /* 100msé‡‡é›†å‘¨æœŸ */
    if (g_systemTick - lastAcquisitionTime >= 100) {

        /* é‡‡é›†æ¸©åº¦æ•°æ® */
        g_sensorData.temperature = SensorManager_ReadTemperature();

        /* é‡‡é›†å‹åŠ›æ•°æ® */
        g_sensorData.pressure = SensorManager_ReadPressure();

        /* é‡‡é›†æµé‡æ•°æ® */
        g_sensorData.flow_rate = SensorManager_ReadFlowRate();

        /* é‡‡é›†æŒ¯åŠ¨æ•°æ® */
        g_sensorData.vibration = SensorManager_ReadVibration();

        /* æ›´æ–°æ•°æ®æ—¶é—´æˆ³ */
        g_sensorData.timestamp = g_systemTick;

        lastAcquisitionTime = g_systemTick;
    }
}

/**
 * @brief æ•°æ®å¤„ç†ä»»åŠ¡
 */
static void Task_DataProcessing(void)
{
    static uint32_t lastProcessingTime = 0;

    /* 500mså¤„ç†å‘¨æœŸ */
    if (g_systemTick - lastProcessingTime >= 500) {

        /* æ•°æ®æ»¤æ³¢å¤„ç† */
        DataLogger_FilterSensorData(&amp;g_sensorData);

        /* æ•°æ®èŒƒå›´æ£€æŸ¥ */
        DataLogger_ValidateSensorData(&amp;g_sensorData);

        /* è®¡ç®—è¡ç”Ÿå‚æ•° */
        g_sensorData.pressure_rate = DataLogger_CalculatePressureRate();
        g_sensorData.flow_total = DataLogger_CalculateFlowTotal();

        /* æ›´æ–°Modbuså¯„å­˜å™¨ */
        ModbusServer_UpdateRegisters(&amp;g_sensorData);

        lastProcessingTime = g_systemTick;
    }
}

/**
 * @brief é€šä¿¡å¤„ç†ä»»åŠ¡
 */
static void Task_Communication(void)
{
    /* Modbus RTUé€šä¿¡å¤„ç† */
    if (HAL_UART_GetState(&amp;huart1) == HAL_UART_STATE_BUSY_RX) {
        ModbusServer_ProcessRTU();
    }

    /* Modbus TCPé€šä¿¡å¤„ç† */
    if (HAL_ETH_GetState(&amp;heth) == HAL_ETH_STATE_BUSY_RX) {
        ModbusServer_ProcessTCP();
    }

    /* USBé€šä¿¡å¤„ç† (è°ƒè¯•ç”¨) */
    if (HAL_UART_GetState(&amp;huart3) == HAL_UART_STATE_BUSY_RX) {
        ProcessUSBCommand();
    }
}

/**
 * @brief ç³»ç»Ÿç›‘æ§ä»»åŠ¡
 */
static void Task_SystemMonitoring(void)
{
    static uint32_t lastMonitorTime = 0;

    /* 1000msç›‘æ§å‘¨æœŸ */
    if (g_systemTick - lastMonitorTime >= 1000) {

        /* æ›´æ–°ç³»ç»Ÿè¿è¡Œæ—¶é—´ */
        g_systemStatus.uptime++;

        /* æ£€æŸ¥ç³»ç»Ÿé”™è¯¯ */
        SystemError_Check();

        /* ç›‘æ§ç”µæºç”µå‹ */
        if (SystemMonitor_GetPowerVoltage() < 20.0) {
            g_systemStatus.error_code |= ERROR_LOW_VOLTAGE;
        }

        /* æ£€æŸ¥å­˜å‚¨ç©ºé—´ */
        if (DataLogger_GetFreeSpace() < 1024) {
            g_systemStatus.error_code |= ERROR_STORAGE_FULL;
        }

        /* ç³»ç»ŸçŠ¶æ€LEDæŒ‡ç¤º */
        SystemStatus_UpdateLED();

        lastMonitorTime = g_systemTick;
    }
}
ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å—
/**
 * @file sensor_manager.c
 * @brief ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å—
 */

#include "sensor_manager.h"
#include "adc.h"
#include "tim.h"
#include "i2c.h"

/* ä¼ æ„Ÿå™¨æ ¡å‡†å‚æ•° */
typedef struct {
    float offset;
    float scale;
    float filter_coefficient;
} SensorCalibration_t;

static SensorCalibration_t tempCalib = {0.0, 1.0, 0.1};
static SensorCalibration_t pressureCalib = {0.0, 1.0, 0.1};

/**
 * @brief æ¸©åº¦ä¼ æ„Ÿå™¨è¯»å– (PT100)
 */
float SensorManager_ReadTemperature(void)
{
    static float filteredTemp = 25.0;
    uint16_t adcValue;
    float voltage, resistance, temperature;

    /* è¯»å–ADCå€¼ */
    adcValue = ADC_ReadChannel(ADC_CHANNEL_TEMP);

    /* è½¬æ¢ä¸ºç”µå‹ */
    voltage = (float)adcValue * 3.3f / 4096.0f;

    /* è®¡ç®—PT100ç”µé˜» */
    resistance = voltage * 1000.0f / 1.0f; /* 1mAæ’æµæº */

    /* PT100ç”µé˜»-æ¸©åº¦è½¬æ¢ (Callendar-Van Dusenæ–¹ç¨‹) */
    if (resistance >= 100.0) {
        temperature = -242.02 + 2.2228 * resistance
                   + 0.00258 * resistance * resistance;
    } else {
        temperature = -242.02 + 2.2228 * resistance;
    }

    /* åº”ç”¨æ ¡å‡†å‚æ•° */
    temperature = temperature * tempCalib.scale + tempCalib.offset;

    /* è½¯ä»¶æ»¤æ³¢ */
    filteredTemp = filteredTemp * (1.0 - tempCalib.filter_coefficient)
                + temperature * tempCalib.filter_coefficient;

    return filteredTemp;
}

/**
 * @brief å‹åŠ›ä¼ æ„Ÿå™¨è¯»å– (4-20mA)
 */
float SensorManager_ReadPressure(void)
{
    static float filteredPressure = 0.0;
    uint16_t adcValue;
    float current, pressure;

    /* è¯»å–ADCå€¼ */
    adcValue = ADC_ReadChannel(ADC_CHANNEL_PRESSURE);

    /* è½¬æ¢ä¸ºç”µæµ (4-20mAå¯¹åº”0.8-4Vç”µå‹) */
    float voltage = (float)adcValue * 3.3f / 4096.0f;
    current = (voltage - 0.8f) * 5.0f; /* 4-20mA */

    /* è½¬æ¢ä¸ºå‹åŠ›å€¼ (0-10Bar) */
    pressure = (current - 4.0f) * 10.0f / 16.0f; /* 4-20mA -> 0-10Bar */

    /* è´Ÿå€¼å¤„ç† */
    if (pressure < 0.0) pressure = 0.0;

    /* åº”ç”¨æ ¡å‡†å‚æ•° */
    pressure = pressure * pressureCalib.scale + pressureCalib.offset;

    /* è½¯ä»¶æ»¤æ³¢ */
    filteredPressure = filteredPressure * (1.0 - pressureCalib.filter_coefficient)
                     + pressure * pressureCalib.filter_coefficient;

    return filteredPressure;
}

/**
 * @brief æµé‡ä¼ æ„Ÿå™¨è¯»å– (è„‰å†²è¾“å‡º)
 */
float SensorManager_ReadFlowRate(void)
{
    static uint32_t lastPulseCount = 0;
    static uint32_t lastReadTime = 0;
    static float flowRate = 0.0;

    uint32_t currentPulseCount, pulseDelta;
    uint32_t timeDelta;
    float frequency;

    /* è·å–å½“å‰è„‰å†²è®¡æ•° */
    currentPulseCount = TIM_GetPulseCount(TIM_FLOW);

    /* è®¡ç®—æ—¶é—´å·® */
    timeDelta = g_systemTick - lastReadTime;
    if (timeDelta > 0) {
        /* è®¡ç®—è„‰å†²å¢é‡ */
        pulseDelta = currentPulseCount - lastPulseCount;

        /* è®¡ç®—é¢‘ç‡ (Hz) */
        frequency = (float)pulseDelta * 1000.0f / (float)timeDelta;

        /* è½¬æ¢ä¸ºæµé‡ (L/min) */
        flowRate = frequency * 60.0f / 100.0f; /* 100è„‰å†²/L */

        /* æ›´æ–°å†å²è®°å½• */
        lastPulseCount = currentPulseCount;
        lastReadTime = g_systemTick;
    }

    return flowRate;
}

/**
 * @brief æŒ¯åŠ¨ä¼ æ„Ÿå™¨è¯»å– (IEPE)
 */
float SensorManager_ReadVibration(void)
{
    uint16_t adcValue;
    float voltage, rmsValue;

    /* è¯»å–ADCå€¼ */
    adcValue = ADC_ReadChannel(ADC_CHANNEL_VIBRATION);

    /* è½¬æ¢ä¸ºç”µå‹ */
    voltage = (float)adcValue * 3.3f / 4096.0f;

    /* è®¡ç®—RMSå€¼ */
    rmsValue = Vibration_CalculateRMS(voltage);

    /* è½¬æ¢ä¸ºåŠ é€Ÿåº¦å€¼ (g) */
    float acceleration = rmsValue * 10.0f; /* 10g/Vçµæ•åº¦ */

    return acceleration;
}
Modbusé€šä¿¡æ¨¡å—
/**
 * @file modbus_server.c
 * @brief ModbusæœåŠ¡å™¨å®ç°
 */

#include "modbus_server.h"
#include "usart.h"
#include "ethernet.h"

/* Modbuså¯„å­˜å™¨æ˜ å°„ */
typedef union {
    struct {
        uint16_t holding_registers[100];
        uint16_t input_registers[100];
        uint16_t coils[100];
        uint16_t discrete_inputs[100];
    } registers;
    uint16_t raw[400];
} ModbusMemoryMap_t;

static ModbusMemoryMap_t g_modbusMemory;

/**
 * @brief Modbuså¯„å­˜å™¨æ˜ å°„
 */
void ModbusServer_UpdateRegisters(SensorData_t* sensorData)
{
    /* è¾“å…¥å¯„å­˜å™¨ (åªè¯») */
    g_modbusMemory.registers.input_registers[0] =
        (uint16_t)(sensorData->temperature * 10.0);  // æ¸©åº¦ (0.1Â°C)
    g_modbusMemory.registers.input_registers[1] =
        (uint16_t)(sensorData->pressure * 100.0);    // å‹åŠ› (0.01Bar)
    g_modbusMemory.registers.input_registers[2] =
        (uint16_t)(sensorData->flow_rate * 10.0);    // æµé‡ (0.1L/min)
    g_modbusMemory.registers.input_registers[3] =
        (uint16_t)(sensorData->vibration * 100.0);   // æŒ¯åŠ¨ (0.01g)

    /* ä¿æŒå¯„å­˜å™¨ (è¯»å†™) */
    g_modbusMemory.registers.holding_registers[0] =
        (uint16_t)(g_systemStatus.mode);            // è¿è¡Œæ¨¡å¼
    g_modbusMemory.registers.holding_registers[1] =
        (uint16_t)(g_systemStatus.error_code);      // é”™è¯¯ä»£ç 
    g_modbusMemory.registers.holding_registers[2] =
        (uint16_t)(g_systemStatus.uptime);          // è¿è¡Œæ—¶é—´
}

/**
 * @brief å¤„ç†Modbus RTUè¯·æ±‚
 */
void ModbusServer_ProcessRTU(void)
{
    static uint8_t rxBuffer[256];
    static uint8_t txBuffer[256];
    uint16_t rxLength, txLength;

    /* æ¥æ”¶æ•°æ® */
    if (UART_ReceiveBuffer(&amp;huart1, rxBuffer, &amp;rxLength)) {

        /* è§£æModbusè¯·æ±‚ */
        ModbusRequest_t request;
        if (Modbus_ParseRequest(rxBuffer, rxLength, &amp;request)) {

            /* å¤„ç†è¯·æ±‚ */
            ModbusResponse_t response;
            Modbus_ProcessRequest(&amp;request, &amp;response);

            /* ç”Ÿæˆå“åº”å¸§ */
            txLength = Modbus_GenerateResponse(&amp;response, txBuffer);

            /* å‘é€å“åº” */
            UART_Transmit(&amp;huart1, txBuffer, txLength);
        }
    }
}

/**
 * @brief å¤„ç†Modbus TCPè¯·æ±‚
 */
void ModbusServer_ProcessTCP(void)
{
    /* TCPé€šä¿¡å¤„ç† (ç®€åŒ–å®ç°) */
    uint8_t tcpBuffer[512];
    uint16_t tcpLength;

    if (Ethernet_ReceiveData(tcpBuffer, &amp;tcpLength)) {
        /* è§£æMBAPå¤´éƒ¨å’ŒModbus PDU */
        ModbusTCP_Request_t tcpRequest;
        if (ModbusTCP_ParseRequest(tcpBuffer, tcpLength, &amp;tcpRequest)) {

            /* å¤„ç†Modbusè¯·æ±‚ */
            ModbusResponse_t response;
            Modbus_ProcessRequest(&amp;tcpRequest.modbus_request, &amp;response);

            /* ç”ŸæˆTCPå“åº” */
            uint16_t responseLength;
            responseLength = ModbusTCP_GenerateResponse(
                &amp;tcpRequest, &amp;response, tcpBuffer);

            /* å‘é€TCPå“åº” */
            Ethernet_TransmitData(tcpBuffer, responseLength);
        }
    }
}

/**
 * @brief å¤„ç†ModbusåŠŸèƒ½ç 
 */
void Modbus_ProcessRequest(ModbusRequest_t* request, ModbusResponse_t* response)
{
    response->slave_address = request->slave_address;
    response->function_code = request->function_code;

    switch (request->function_code) {
        case MODBUS_FC_READ_HOLDING_REGISTERS:
            Modbus_ReadHoldingRegisters(request, response);
            break;

        case MODBUS_FC_READ_INPUT_REGISTERS:
            Modbus_ReadInputRegisters(request, response);
            break;

        case MODBUS_FC_WRITE_SINGLE_REGISTER:
            Modbus_WriteSingleRegister(request, response);
            break;

        case MODBUS_FC_WRITE_MULTIPLE_REGISTERS:
            Modbus_WriteMultipleRegisters(request, response);
            break;

        default:
            response->function_code |= 0x80; // å¼‚å¸¸å“åº”
            response->data[0] = MODBUS_EXCEPTION_ILLEGAL_FUNCTION;
            response->data_length = 1;
            break;
    }
}
ğŸ“Š æ•°æ®è®°å½•ä¸åˆ†æ
æ•°æ®è®°å½•åŠŸèƒ½
/**
 * @file data_logger.c
 * @brief æ•°æ®è®°å½•æ¨¡å—
 */

#include "data_logger.h"
#include "flash.h"
#include "rtc.h"

/* æ•°æ®è®°å½•ç»“æ„ */
typedef struct {
    uint32_t timestamp;
    float temperature;
    float pressure;
    float flow_rate;
    float vibration;
    uint16_t system_status;
} DataRecord_t;

/* å†å²æ•°æ®ç¼“å†²åŒº */
#define DATA_BUFFER_SIZE  1000
static DataRecord_t g_dataBuffer[DATA_BUFFER_SIZE];
static uint16_t g_dataBufferIndex = 0;
static uint32_t g_totalRecords = 0;

/**
 * @brief è®°å½•ä¼ æ„Ÿå™¨æ•°æ®
 */
void DataLogger_RecordData(SensorData_t* sensorData)
{
    DataRecord_t* record = &amp;g_dataBuffer[g_dataBufferIndex];

    /* å¡«å……æ•°æ®è®°å½• */
    record->timestamp = RTC_GetTimestamp();
    record->temperature = sensorData->temperature;
    record->pressure = sensorData->pressure;
    record->flow_rate = sensorData->flow_rate;
    record->vibration = sensorData->vibration;
    record->system_status = g_systemStatus.error_code;

    /* æ›´æ–°ç¼“å†²åŒºç´¢å¼• */
    g_dataBufferIndex = (g_dataBufferIndex + 1) % DATA_BUFFER_SIZE;
    g_totalRecords++;

    /* æ£€æŸ¥æ˜¯å¦éœ€è¦ä¿å­˜åˆ°Flash */
    if (g_dataBufferIndex % 100 == 0) {
        DataLogger_SaveToFlash();
    }
}

/**
 * @brief æ•°æ®æ»¤æ³¢å¤„ç†
 */
void DataLogger_FilterSensorData(SensorData_t* sensorData)
{
    static SensorData_t filterBuffer[5];
    static uint8_t filterIndex = 0;

    /* æ›´æ–°æ»¤æ³¢ç¼“å†²åŒº */
    filterBuffer[filterIndex] = *sensorData;
    filterIndex = (filterIndex + 1) % 5;

    /* è®¡ç®—ç§»åŠ¨å¹³å‡å€¼ */
    float tempSum = 0.0, pressureSum = 0.0;
    float flowSum = 0.0, vibrationSum = 0.0;

    for (int i = 0; i < 5; i++) {
        tempSum += filterBuffer[i].temperature;
        pressureSum += filterBuffer[i].pressure;
        flowSum += filterBuffer[i].flow_rate;
        vibrationSum += filterBuffer[i].vibration;
    }

    sensorData->temperature = tempSum / 5.0;
    sensorData->pressure = pressureSum / 5.0;
    sensorData->flow_rate = flowSum / 5.0;
    sensorData->vibration = vibrationSum / 5.0;
}

/**
 * @brief æ•°æ®æœ‰æ•ˆæ€§æ£€æŸ¥
 */
bool DataLogger_ValidateSensorData(SensorData_t* sensorData)
{
    bool isValid = true;

    /* æ¸©åº¦èŒƒå›´æ£€æŸ¥ */
    if (sensorData->temperature < -40.0 || sensorData->temperature > 125.0) {
        sensorData->temperature = 25.0; // é»˜è®¤å€¼
        isValid = false;
    }

    /* å‹åŠ›èŒƒå›´æ£€æŸ¥ */
    if (sensorData->pressure < 0.0 || sensorData->pressure > 20.0) {
        sensorData->pressure = 0.0;
        isValid = false;
    }

    /* æµé‡èŒƒå›´æ£€æŸ¥ */
    if (sensorData->flow_rate < 0.0 || sensorData->flow_rate > 1000.0) {
        sensorData->flow_rate = 0.0;
        isValid = false;
    }

    /* æŒ¯åŠ¨èŒƒå›´æ£€æŸ¥ */
    if (sensorData->vibration < 0.0 || sensorData->vibration > 50.0) {
        sensorData->vibration = 0.0;
        isValid = false;
    }

    return isValid;
}
ğŸ”§ ç³»ç»Ÿæµ‹è¯•ä¸éªŒè¯
åŠŸèƒ½æµ‹è¯•æ¸…å•
ç¡¬ä»¶æµ‹è¯•:
âœ“ ç”µæºè¾“å…¥æµ‹è¯• (24V DC Â±10%)
âœ“ å·¥ä½œæ¸©åº¦æµ‹è¯• (-20Â°C ~ +70Â°C)
âœ“ EMIæŠ—å¹²æ‰°æµ‹è¯• (IEC 61000-4-3)
âœ“ é˜²æŠ¤ç­‰çº§æµ‹è¯• (IP65)
âœ“ æŒ¯åŠ¨æµ‹è¯• (IEC 60068-2-6)

è½¯ä»¶æµ‹è¯•:
âœ“ ä¼ æ„Ÿå™¨ç²¾åº¦æµ‹è¯• (Â±0.1%)
âœ“ Modbusé€šä¿¡æµ‹è¯• (RTU/TCP)
âœ“ æ•°æ®è®°å½•æµ‹è¯• (1000æ¡/ç§’)
âœ“ çœ‹é—¨ç‹—åŠŸèƒ½æµ‹è¯•
âœ“ æ•…éšœæ¢å¤æµ‹è¯•

æ€§èƒ½æŒ‡æ ‡:
âœ“ å¯åŠ¨æ—¶é—´: < 2ç§’
âœ“ æ•°æ®æ›´æ–°é¢‘ç‡: 10Hz
âœ“ é€šä¿¡å“åº”æ—¶é—´: < 100ms
âœ“ å­˜å‚¨å®¹é‡: 10,000æ¡è®°å½•
âœ“ åŠŸè€—: < 5W
ç°åœºæµ‹è¯•ç»“æœ
æµ‹è¯•ç¯å¢ƒ: å·¥ä¸šæ³µç«™ç°åœº
æµ‹è¯•æ—¶é—´: 72å°æ—¶è¿ç»­è¿è¡Œ

ä¼ æ„Ÿå™¨æµ‹è¯•ç»“æœ:
- æ¸©åº¦æµ‹é‡ç²¾åº¦: Â±0.05Â°C (PT100, 0-100Â°CèŒƒå›´)
- å‹åŠ›æµ‹é‡ç²¾åº¦: Â±0.2%FS (4-20mA, 0-10Bar)
- æµé‡æµ‹é‡ç²¾åº¦: Â±1.0% (è„‰å†²è¾“å‡º, 0-500L/min)
- æŒ¯åŠ¨æµ‹é‡ç²¾åº¦: Â±5% (IEPE, 0-10g)

é€šä¿¡æµ‹è¯•ç»“æœ:
- Modbus RTU: 9600bps, 0é”™è¯¯
- Modbus TCP: 100Mbps, <10mså»¶è¿Ÿ
- æ•°æ®å®Œæ•´æ€§: 99.99%
- è¿æ¥ç¨³å®šæ€§: 72å°æ—¶æ— æ–­çº¿

ç³»ç»Ÿç¨³å®šæ€§:
- è¿ç»­è¿è¡Œæ—¶é—´: 72å°æ—¶
- å†…å­˜ä½¿ç”¨ç‡: 45%
- CPUä½¿ç”¨ç‡: 30%
- å­˜å‚¨ç©ºé—´ä½¿ç”¨: 23%
ğŸ“ˆ é¡¹ç›®åº”ç”¨åœºæ™¯
å·¥ä¸šåº”ç”¨æ¡ˆä¾‹


æ³µç«™ç›‘æ§ç³»ç»Ÿ'><meta name=author content="dmk69"><link rel=canonical href=https://hugo-maker-blog.vercel.app/projects/embedded-control-unit/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://hugo-maker-blog.vercel.app/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://hugo-maker-blog.vercel.app/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://hugo-maker-blog.vercel.app/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://hugo-maker-blog.vercel.app/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://hugo-maker-blog.vercel.app/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://hugo-maker-blog.vercel.app/projects/embedded-control-unit/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://hugo-maker-blog.vercel.app/projects/embedded-control-unit/"><meta property="og:site_name" content="Automation & Industrial Control Technician"><meta property="og:title" content="æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒ"><meta property="og:description" content='ğŸ”§ é¡¹ç›®æ¦‚è¿° è¿™æ˜¯ä¸€ä¸ªåŸºäºSTM32F4ç³»åˆ—å¾®æ§åˆ¶å™¨çš„æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒï¼Œä¸“é—¨ç”¨äºå·¥ä¸šç°åœºçš„æ•°æ®é‡‡é›†ã€è®¾å¤‡æ§åˆ¶å’Œæ•°æ®é€šä¿¡ã€‚è¯¥æ§åˆ¶å•å…ƒé›†æˆäº†å¤šç§å·¥ä¸šä¼ æ„Ÿå™¨ï¼Œæ”¯æŒModbus RTU/TCPé€šä¿¡åè®®ï¼Œå¯ä½œä¸ºPLCç³»ç»Ÿçš„è¡¥å……æ§åˆ¶å™¨æˆ–ç‹¬ç«‹çš„ç›‘æ§èŠ‚ç‚¹ä½¿ç”¨ã€‚
ğŸ¯ é¡¹ç›®ç›®æ ‡ å®ç°å¤šä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†å’Œé¢„å¤„ç† æä¾›æœ¬åœ°æ§åˆ¶å’Œä¿æŠ¤åŠŸèƒ½ æ”¯æŒModbuså·¥ä¸šé€šä¿¡åè®® å…·å¤‡æ•°æ®è®°å½•å’Œæ•…éšœè¯Šæ–­èƒ½åŠ› æ»¡è¶³å·¥ä¸šç¯å¢ƒçš„å¯é æ€§è¦æ±‚ ğŸ”§ ç¡¬ä»¶æ¶æ„ STM32æ§åˆ¶æ¿è®¾è®¡ ç¡¬ä»¶é…ç½®: ä¸»æ§åˆ¶å™¨: â”œâ”€â”€ STM32F407VGT6 (ARM Cortex-M4, 168MHz) â”œâ”€â”€ 1MB Flash, 192KB RAM â”œâ”€â”€ 3Ã—UART (é€šä¿¡æ¥å£) â”œâ”€â”€ 2Ã—I2C (ä¼ æ„Ÿå™¨æ‰©å±•) â”œâ”€â”€ 3Ã—SPI (é«˜é€Ÿæ•°æ®æ¥å£) â”œâ”€â”€ 16Ã—12ä½ADC (æ¨¡æ‹Ÿé‡é‡‡é›†) â””â”€â”€ 2Ã—12ä½DAC (æ¨¡æ‹Ÿé‡è¾“å‡º) ç”µæºç®¡ç†: â”œâ”€â”€ 24V DCå·¥ä¸šç”µæºè¾“å…¥ â”œâ”€â”€ 5V/3.3V DC-DCè½¬æ¢å™¨ â”œâ”€â”€ ç”µæºæ»¤æ³¢å’Œä¿æŠ¤ç”µè·¯ â”œâ”€â”€ å¤‡ç”¨ç”µæ±  (RTCå’Œæ•°æ®ä¿æŒ) â””â”€â”€ çœ‹é—¨ç‹—å®šæ—¶å™¨ é€šä¿¡æ¥å£: â”œâ”€â”€ RS485æ¥å£ (Modbus RTU) â”œâ”€â”€ Ethernetæ¥å£ (Modbus TCP) â”œâ”€â”€ USBæ¥å£ (è°ƒè¯•å’Œé…ç½®) â”œâ”€â”€ CANæ€»çº¿æ¥å£ (è®¾å¤‡äº’è”) â””â”€â”€ WiFiæ¨¡å— (å¯é€‰æ— çº¿é€šä¿¡) ä¼ æ„Ÿå™¨æ¥å£ç”µè·¯ ä¼ æ„Ÿå™¨è¿æ¥: â”œâ”€â”€ æ¸©åº¦ä¼ æ„Ÿå™¨ (PT100) â”‚ â”œâ”€â”€ æ’æµæºæ¿€åŠ±ç”µè·¯ â”‚ â”œâ”€â”€ ä¿¡å·æ”¾å¤§å’Œæ»¤æ³¢ â”‚ â””â”€â”€ å†·ç«¯è¡¥å¿ â”œâ”€â”€ å‹åŠ›ä¼ æ„Ÿå™¨ (4-20mA) â”‚ â”œâ”€â”€ ç²¾å¯†ç”µé˜»é‡‡æ · â”‚ â”œâ”€â”€ è¿‡å‹ä¿æŠ¤ â”‚ â””â”€â”€ ä¿¡å·éš”ç¦» â”œâ”€â”€ æµé‡è®¡ (è„‰å†²è¾“å‡º) â”‚ â”œâ”€â”€ å…‰ç”µéš”ç¦»è¾“å…¥ â”‚ â”œâ”€â”€ é¢‘ç‡æµ‹é‡ç”µè·¯ â”‚ â””â”€â”€ æŠ—å¹²æ‰°æ»¤æ³¢ â””â”€â”€ æŒ¯åŠ¨ä¼ æ„Ÿå™¨ (IEPE) â”œâ”€â”€ æ’æµæºä¾›ç”µ â”œâ”€â”€ ACä¿¡å·æ”¾å¤§ â””â”€â”€ RMSè½¬æ¢ç”µè·¯ ğŸ’» è½¯ä»¶æ¶æ„ ä¸»ç¨‹åºæ¡†æ¶ /** * @file main.c * @brief æ™ºèƒ½æ§åˆ¶å•å…ƒä¸»ç¨‹åº * @author Automation Technician * @date 2025-11-12 */ #include "main.h" #include "sensor_manager.h" #include "modbus_server.h" #include "data_logger.h" #include "watchdog.h" #include "system_config.h" /* å…¨å±€å˜é‡å®šä¹‰ */ SystemStatus_t g_systemStatus; SensorData_t g_sensorData; ModbusRegisters_t g_modbusRegisters; uint32_t g_systemTick = 0; /* å‡½æ•°å£°æ˜ */ static void SystemClock_Config(void); static void GPIO_Init(void); static void Peripherals_Init(void); static void Task_SensorAcquisition(void); static void Task_DataProcessing(void); static void Task_Communication(void); static void Task_SystemMonitoring(void); /** * @brief ä¸»å‡½æ•° */ int main(void) { /* ç³»ç»Ÿåˆå§‹åŒ– */ HAL_Init(); SystemClock_Config(); GPIO_Init(); Peripherals_Init(); /* å¤–è®¾åˆå§‹åŒ– */ SensorManager_Init(); ModbusServer_Init(); DataLogger_Init(); Watchdog_Init(); /* ç³»ç»ŸçŠ¶æ€åˆå§‹åŒ– */ g_systemStatus.mode = MODE_AUTO; g_systemStatus.error_code = ERROR_NONE; g_systemStatus.uptime = 0; /* ä¸»å¾ªç¯ */ while (1) { g_systemTick = HAL_GetTick(); /* ä»»åŠ¡è°ƒåº¦ */ Task_SensorAcquisition(); // 100mså‘¨æœŸ Task_DataProcessing(); // 500mså‘¨æœŸ Task_Communication(); // å®æ—¶å¤„ç† Task_SystemMonitoring(); // 1000mså‘¨æœŸ /* å–‚ç‹— */ Watchdog_Refresh(); /* ä½åŠŸè€—å¤„ç† */ if (g_systemStatus.mode == MODE_SLEEP) { __WFI(); } } } /** * @brief ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†ä»»åŠ¡ */ static void Task_SensorAcquisition(void) { static uint32_t lastAcquisitionTime = 0; /* 100msé‡‡é›†å‘¨æœŸ */ if (g_systemTick - lastAcquisitionTime >= 100) { /* é‡‡é›†æ¸©åº¦æ•°æ® */ g_sensorData.temperature = SensorManager_ReadTemperature(); /* é‡‡é›†å‹åŠ›æ•°æ® */ g_sensorData.pressure = SensorManager_ReadPressure(); /* é‡‡é›†æµé‡æ•°æ® */ g_sensorData.flow_rate = SensorManager_ReadFlowRate(); /* é‡‡é›†æŒ¯åŠ¨æ•°æ® */ g_sensorData.vibration = SensorManager_ReadVibration(); /* æ›´æ–°æ•°æ®æ—¶é—´æˆ³ */ g_sensorData.timestamp = g_systemTick; lastAcquisitionTime = g_systemTick; } } /** * @brief æ•°æ®å¤„ç†ä»»åŠ¡ */ static void Task_DataProcessing(void) { static uint32_t lastProcessingTime = 0; /* 500mså¤„ç†å‘¨æœŸ */ if (g_systemTick - lastProcessingTime >= 500) { /* æ•°æ®æ»¤æ³¢å¤„ç† */ DataLogger_FilterSensorData(&amp;g_sensorData); /* æ•°æ®èŒƒå›´æ£€æŸ¥ */ DataLogger_ValidateSensorData(&amp;g_sensorData); /* è®¡ç®—è¡ç”Ÿå‚æ•° */ g_sensorData.pressure_rate = DataLogger_CalculatePressureRate(); g_sensorData.flow_total = DataLogger_CalculateFlowTotal(); /* æ›´æ–°Modbuså¯„å­˜å™¨ */ ModbusServer_UpdateRegisters(&amp;g_sensorData); lastProcessingTime = g_systemTick; } } /** * @brief é€šä¿¡å¤„ç†ä»»åŠ¡ */ static void Task_Communication(void) { /* Modbus RTUé€šä¿¡å¤„ç† */ if (HAL_UART_GetState(&amp;huart1) == HAL_UART_STATE_BUSY_RX) { ModbusServer_ProcessRTU(); } /* Modbus TCPé€šä¿¡å¤„ç† */ if (HAL_ETH_GetState(&amp;heth) == HAL_ETH_STATE_BUSY_RX) { ModbusServer_ProcessTCP(); } /* USBé€šä¿¡å¤„ç† (è°ƒè¯•ç”¨) */ if (HAL_UART_GetState(&amp;huart3) == HAL_UART_STATE_BUSY_RX) { ProcessUSBCommand(); } } /** * @brief ç³»ç»Ÿç›‘æ§ä»»åŠ¡ */ static void Task_SystemMonitoring(void) { static uint32_t lastMonitorTime = 0; /* 1000msç›‘æ§å‘¨æœŸ */ if (g_systemTick - lastMonitorTime >= 1000) { /* æ›´æ–°ç³»ç»Ÿè¿è¡Œæ—¶é—´ */ g_systemStatus.uptime++; /* æ£€æŸ¥ç³»ç»Ÿé”™è¯¯ */ SystemError_Check(); /* ç›‘æ§ç”µæºç”µå‹ */ if (SystemMonitor_GetPowerVoltage() < 20.0) { g_systemStatus.error_code |= ERROR_LOW_VOLTAGE; } /* æ£€æŸ¥å­˜å‚¨ç©ºé—´ */ if (DataLogger_GetFreeSpace() < 1024) { g_systemStatus.error_code |= ERROR_STORAGE_FULL; } /* ç³»ç»ŸçŠ¶æ€LEDæŒ‡ç¤º */ SystemStatus_UpdateLED(); lastMonitorTime = g_systemTick; } } ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å— /** * @file sensor_manager.c * @brief ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å— */ #include "sensor_manager.h" #include "adc.h" #include "tim.h" #include "i2c.h" /* ä¼ æ„Ÿå™¨æ ¡å‡†å‚æ•° */ typedef struct { float offset; float scale; float filter_coefficient; } SensorCalibration_t; static SensorCalibration_t tempCalib = {0.0, 1.0, 0.1}; static SensorCalibration_t pressureCalib = {0.0, 1.0, 0.1}; /** * @brief æ¸©åº¦ä¼ æ„Ÿå™¨è¯»å– (PT100) */ float SensorManager_ReadTemperature(void) { static float filteredTemp = 25.0; uint16_t adcValue; float voltage, resistance, temperature; /* è¯»å–ADCå€¼ */ adcValue = ADC_ReadChannel(ADC_CHANNEL_TEMP); /* è½¬æ¢ä¸ºç”µå‹ */ voltage = (float)adcValue * 3.3f / 4096.0f; /* è®¡ç®—PT100ç”µé˜» */ resistance = voltage * 1000.0f / 1.0f; /* 1mAæ’æµæº */ /* PT100ç”µé˜»-æ¸©åº¦è½¬æ¢ (Callendar-Van Dusenæ–¹ç¨‹) */ if (resistance >= 100.0) { temperature = -242.02 + 2.2228 * resistance + 0.00258 * resistance * resistance; } else { temperature = -242.02 + 2.2228 * resistance; } /* åº”ç”¨æ ¡å‡†å‚æ•° */ temperature = temperature * tempCalib.scale + tempCalib.offset; /* è½¯ä»¶æ»¤æ³¢ */ filteredTemp = filteredTemp * (1.0 - tempCalib.filter_coefficient) + temperature * tempCalib.filter_coefficient; return filteredTemp; } /** * @brief å‹åŠ›ä¼ æ„Ÿå™¨è¯»å– (4-20mA) */ float SensorManager_ReadPressure(void) { static float filteredPressure = 0.0; uint16_t adcValue; float current, pressure; /* è¯»å–ADCå€¼ */ adcValue = ADC_ReadChannel(ADC_CHANNEL_PRESSURE); /* è½¬æ¢ä¸ºç”µæµ (4-20mAå¯¹åº”0.8-4Vç”µå‹) */ float voltage = (float)adcValue * 3.3f / 4096.0f; current = (voltage - 0.8f) * 5.0f; /* 4-20mA */ /* è½¬æ¢ä¸ºå‹åŠ›å€¼ (0-10Bar) */ pressure = (current - 4.0f) * 10.0f / 16.0f; /* 4-20mA -> 0-10Bar */ /* è´Ÿå€¼å¤„ç† */ if (pressure < 0.0) pressure = 0.0; /* åº”ç”¨æ ¡å‡†å‚æ•° */ pressure = pressure * pressureCalib.scale + pressureCalib.offset; /* è½¯ä»¶æ»¤æ³¢ */ filteredPressure = filteredPressure * (1.0 - pressureCalib.filter_coefficient) + pressure * pressureCalib.filter_coefficient; return filteredPressure; } /** * @brief æµé‡ä¼ æ„Ÿå™¨è¯»å– (è„‰å†²è¾“å‡º) */ float SensorManager_ReadFlowRate(void) { static uint32_t lastPulseCount = 0; static uint32_t lastReadTime = 0; static float flowRate = 0.0; uint32_t currentPulseCount, pulseDelta; uint32_t timeDelta; float frequency; /* è·å–å½“å‰è„‰å†²è®¡æ•° */ currentPulseCount = TIM_GetPulseCount(TIM_FLOW); /* è®¡ç®—æ—¶é—´å·® */ timeDelta = g_systemTick - lastReadTime; if (timeDelta > 0) { /* è®¡ç®—è„‰å†²å¢é‡ */ pulseDelta = currentPulseCount - lastPulseCount; /* è®¡ç®—é¢‘ç‡ (Hz) */ frequency = (float)pulseDelta * 1000.0f / (float)timeDelta; /* è½¬æ¢ä¸ºæµé‡ (L/min) */ flowRate = frequency * 60.0f / 100.0f; /* 100è„‰å†²/L */ /* æ›´æ–°å†å²è®°å½• */ lastPulseCount = currentPulseCount; lastReadTime = g_systemTick; } return flowRate; } /** * @brief æŒ¯åŠ¨ä¼ æ„Ÿå™¨è¯»å– (IEPE) */ float SensorManager_ReadVibration(void) { uint16_t adcValue; float voltage, rmsValue; /* è¯»å–ADCå€¼ */ adcValue = ADC_ReadChannel(ADC_CHANNEL_VIBRATION); /* è½¬æ¢ä¸ºç”µå‹ */ voltage = (float)adcValue * 3.3f / 4096.0f; /* è®¡ç®—RMSå€¼ */ rmsValue = Vibration_CalculateRMS(voltage); /* è½¬æ¢ä¸ºåŠ é€Ÿåº¦å€¼ (g) */ float acceleration = rmsValue * 10.0f; /* 10g/Vçµæ•åº¦ */ return acceleration; } Modbusé€šä¿¡æ¨¡å— /** * @file modbus_server.c * @brief ModbusæœåŠ¡å™¨å®ç° */ #include "modbus_server.h" #include "usart.h" #include "ethernet.h" /* Modbuså¯„å­˜å™¨æ˜ å°„ */ typedef union { struct { uint16_t holding_registers[100]; uint16_t input_registers[100]; uint16_t coils[100]; uint16_t discrete_inputs[100]; } registers; uint16_t raw[400]; } ModbusMemoryMap_t; static ModbusMemoryMap_t g_modbusMemory; /** * @brief Modbuså¯„å­˜å™¨æ˜ å°„ */ void ModbusServer_UpdateRegisters(SensorData_t* sensorData) { /* è¾“å…¥å¯„å­˜å™¨ (åªè¯») */ g_modbusMemory.registers.input_registers[0] = (uint16_t)(sensorData->temperature * 10.0); // æ¸©åº¦ (0.1Â°C) g_modbusMemory.registers.input_registers[1] = (uint16_t)(sensorData->pressure * 100.0); // å‹åŠ› (0.01Bar) g_modbusMemory.registers.input_registers[2] = (uint16_t)(sensorData->flow_rate * 10.0); // æµé‡ (0.1L/min) g_modbusMemory.registers.input_registers[3] = (uint16_t)(sensorData->vibration * 100.0); // æŒ¯åŠ¨ (0.01g) /* ä¿æŒå¯„å­˜å™¨ (è¯»å†™) */ g_modbusMemory.registers.holding_registers[0] = (uint16_t)(g_systemStatus.mode); // è¿è¡Œæ¨¡å¼ g_modbusMemory.registers.holding_registers[1] = (uint16_t)(g_systemStatus.error_code); // é”™è¯¯ä»£ç  g_modbusMemory.registers.holding_registers[2] = (uint16_t)(g_systemStatus.uptime); // è¿è¡Œæ—¶é—´ } /** * @brief å¤„ç†Modbus RTUè¯·æ±‚ */ void ModbusServer_ProcessRTU(void) { static uint8_t rxBuffer[256]; static uint8_t txBuffer[256]; uint16_t rxLength, txLength; /* æ¥æ”¶æ•°æ® */ if (UART_ReceiveBuffer(&amp;huart1, rxBuffer, &amp;rxLength)) { /* è§£æModbusè¯·æ±‚ */ ModbusRequest_t request; if (Modbus_ParseRequest(rxBuffer, rxLength, &amp;request)) { /* å¤„ç†è¯·æ±‚ */ ModbusResponse_t response; Modbus_ProcessRequest(&amp;request, &amp;response); /* ç”Ÿæˆå“åº”å¸§ */ txLength = Modbus_GenerateResponse(&amp;response, txBuffer); /* å‘é€å“åº” */ UART_Transmit(&amp;huart1, txBuffer, txLength); } } } /** * @brief å¤„ç†Modbus TCPè¯·æ±‚ */ void ModbusServer_ProcessTCP(void) { /* TCPé€šä¿¡å¤„ç† (ç®€åŒ–å®ç°) */ uint8_t tcpBuffer[512]; uint16_t tcpLength; if (Ethernet_ReceiveData(tcpBuffer, &amp;tcpLength)) { /* è§£æMBAPå¤´éƒ¨å’ŒModbus PDU */ ModbusTCP_Request_t tcpRequest; if (ModbusTCP_ParseRequest(tcpBuffer, tcpLength, &amp;tcpRequest)) { /* å¤„ç†Modbusè¯·æ±‚ */ ModbusResponse_t response; Modbus_ProcessRequest(&amp;tcpRequest.modbus_request, &amp;response); /* ç”ŸæˆTCPå“åº” */ uint16_t responseLength; responseLength = ModbusTCP_GenerateResponse( &amp;tcpRequest, &amp;response, tcpBuffer); /* å‘é€TCPå“åº” */ Ethernet_TransmitData(tcpBuffer, responseLength); } } } /** * @brief å¤„ç†ModbusåŠŸèƒ½ç  */ void Modbus_ProcessRequest(ModbusRequest_t* request, ModbusResponse_t* response) { response->slave_address = request->slave_address; response->function_code = request->function_code; switch (request->function_code) { case MODBUS_FC_READ_HOLDING_REGISTERS: Modbus_ReadHoldingRegisters(request, response); break; case MODBUS_FC_READ_INPUT_REGISTERS: Modbus_ReadInputRegisters(request, response); break; case MODBUS_FC_WRITE_SINGLE_REGISTER: Modbus_WriteSingleRegister(request, response); break; case MODBUS_FC_WRITE_MULTIPLE_REGISTERS: Modbus_WriteMultipleRegisters(request, response); break; default: response->function_code |= 0x80; // å¼‚å¸¸å“åº” response->data[0] = MODBUS_EXCEPTION_ILLEGAL_FUNCTION; response->data_length = 1; break; } } ğŸ“Š æ•°æ®è®°å½•ä¸åˆ†æ æ•°æ®è®°å½•åŠŸèƒ½ /** * @file data_logger.c * @brief æ•°æ®è®°å½•æ¨¡å— */ #include "data_logger.h" #include "flash.h" #include "rtc.h" /* æ•°æ®è®°å½•ç»“æ„ */ typedef struct { uint32_t timestamp; float temperature; float pressure; float flow_rate; float vibration; uint16_t system_status; } DataRecord_t; /* å†å²æ•°æ®ç¼“å†²åŒº */ #define DATA_BUFFER_SIZE 1000 static DataRecord_t g_dataBuffer[DATA_BUFFER_SIZE]; static uint16_t g_dataBufferIndex = 0; static uint32_t g_totalRecords = 0; /** * @brief è®°å½•ä¼ æ„Ÿå™¨æ•°æ® */ void DataLogger_RecordData(SensorData_t* sensorData) { DataRecord_t* record = &amp;g_dataBuffer[g_dataBufferIndex]; /* å¡«å……æ•°æ®è®°å½• */ record->timestamp = RTC_GetTimestamp(); record->temperature = sensorData->temperature; record->pressure = sensorData->pressure; record->flow_rate = sensorData->flow_rate; record->vibration = sensorData->vibration; record->system_status = g_systemStatus.error_code; /* æ›´æ–°ç¼“å†²åŒºç´¢å¼• */ g_dataBufferIndex = (g_dataBufferIndex + 1) % DATA_BUFFER_SIZE; g_totalRecords++; /* æ£€æŸ¥æ˜¯å¦éœ€è¦ä¿å­˜åˆ°Flash */ if (g_dataBufferIndex % 100 == 0) { DataLogger_SaveToFlash(); } } /** * @brief æ•°æ®æ»¤æ³¢å¤„ç† */ void DataLogger_FilterSensorData(SensorData_t* sensorData) { static SensorData_t filterBuffer[5]; static uint8_t filterIndex = 0; /* æ›´æ–°æ»¤æ³¢ç¼“å†²åŒº */ filterBuffer[filterIndex] = *sensorData; filterIndex = (filterIndex + 1) % 5; /* è®¡ç®—ç§»åŠ¨å¹³å‡å€¼ */ float tempSum = 0.0, pressureSum = 0.0; float flowSum = 0.0, vibrationSum = 0.0; for (int i = 0; i < 5; i++) { tempSum += filterBuffer[i].temperature; pressureSum += filterBuffer[i].pressure; flowSum += filterBuffer[i].flow_rate; vibrationSum += filterBuffer[i].vibration; } sensorData->temperature = tempSum / 5.0; sensorData->pressure = pressureSum / 5.0; sensorData->flow_rate = flowSum / 5.0; sensorData->vibration = vibrationSum / 5.0; } /** * @brief æ•°æ®æœ‰æ•ˆæ€§æ£€æŸ¥ */ bool DataLogger_ValidateSensorData(SensorData_t* sensorData) { bool isValid = true; /* æ¸©åº¦èŒƒå›´æ£€æŸ¥ */ if (sensorData->temperature < -40.0 || sensorData->temperature > 125.0) { sensorData->temperature = 25.0; // é»˜è®¤å€¼ isValid = false; } /* å‹åŠ›èŒƒå›´æ£€æŸ¥ */ if (sensorData->pressure < 0.0 || sensorData->pressure > 20.0) { sensorData->pressure = 0.0; isValid = false; } /* æµé‡èŒƒå›´æ£€æŸ¥ */ if (sensorData->flow_rate < 0.0 || sensorData->flow_rate > 1000.0) { sensorData->flow_rate = 0.0; isValid = false; } /* æŒ¯åŠ¨èŒƒå›´æ£€æŸ¥ */ if (sensorData->vibration < 0.0 || sensorData->vibration > 50.0) { sensorData->vibration = 0.0; isValid = false; } return isValid; } ğŸ”§ ç³»ç»Ÿæµ‹è¯•ä¸éªŒè¯ åŠŸèƒ½æµ‹è¯•æ¸…å• ç¡¬ä»¶æµ‹è¯•: âœ“ ç”µæºè¾“å…¥æµ‹è¯• (24V DC Â±10%) âœ“ å·¥ä½œæ¸©åº¦æµ‹è¯• (-20Â°C ~ +70Â°C) âœ“ EMIæŠ—å¹²æ‰°æµ‹è¯• (IEC 61000-4-3) âœ“ é˜²æŠ¤ç­‰çº§æµ‹è¯• (IP65) âœ“ æŒ¯åŠ¨æµ‹è¯• (IEC 60068-2-6) è½¯ä»¶æµ‹è¯•: âœ“ ä¼ æ„Ÿå™¨ç²¾åº¦æµ‹è¯• (Â±0.1%) âœ“ Modbusé€šä¿¡æµ‹è¯• (RTU/TCP) âœ“ æ•°æ®è®°å½•æµ‹è¯• (1000æ¡/ç§’) âœ“ çœ‹é—¨ç‹—åŠŸèƒ½æµ‹è¯• âœ“ æ•…éšœæ¢å¤æµ‹è¯• æ€§èƒ½æŒ‡æ ‡: âœ“ å¯åŠ¨æ—¶é—´: < 2ç§’ âœ“ æ•°æ®æ›´æ–°é¢‘ç‡: 10Hz âœ“ é€šä¿¡å“åº”æ—¶é—´: < 100ms âœ“ å­˜å‚¨å®¹é‡: 10,000æ¡è®°å½• âœ“ åŠŸè€—: < 5W ç°åœºæµ‹è¯•ç»“æœ æµ‹è¯•ç¯å¢ƒ: å·¥ä¸šæ³µç«™ç°åœº æµ‹è¯•æ—¶é—´: 72å°æ—¶è¿ç»­è¿è¡Œ ä¼ æ„Ÿå™¨æµ‹è¯•ç»“æœ: - æ¸©åº¦æµ‹é‡ç²¾åº¦: Â±0.05Â°C (PT100, 0-100Â°CèŒƒå›´) - å‹åŠ›æµ‹é‡ç²¾åº¦: Â±0.2%FS (4-20mA, 0-10Bar) - æµé‡æµ‹é‡ç²¾åº¦: Â±1.0% (è„‰å†²è¾“å‡º, 0-500L/min) - æŒ¯åŠ¨æµ‹é‡ç²¾åº¦: Â±5% (IEPE, 0-10g) é€šä¿¡æµ‹è¯•ç»“æœ: - Modbus RTU: 9600bps, 0é”™è¯¯ - Modbus TCP: 100Mbps, <10mså»¶è¿Ÿ - æ•°æ®å®Œæ•´æ€§: 99.99% - è¿æ¥ç¨³å®šæ€§: 72å°æ—¶æ— æ–­çº¿ ç³»ç»Ÿç¨³å®šæ€§: - è¿ç»­è¿è¡Œæ—¶é—´: 72å°æ—¶ - å†…å­˜ä½¿ç”¨ç‡: 45% - CPUä½¿ç”¨ç‡: 30% - å­˜å‚¨ç©ºé—´ä½¿ç”¨: 23% ğŸ“ˆ é¡¹ç›®åº”ç”¨åœºæ™¯ å·¥ä¸šåº”ç”¨æ¡ˆä¾‹ æ³µç«™ç›‘æ§ç³»ç»Ÿ'><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="projects"><meta property="article:published_time" content="2025-11-12T12:00:00+08:00"><meta property="article:modified_time" content="2025-11-12T12:00:00+08:00"><meta property="article:tag" content="STM32"><meta property="article:tag" content="Cè¯­è¨€"><meta property="article:tag" content="Modbus"><meta property="article:tag" content="ä¼ æ„Ÿå™¨"><meta property="article:tag" content="åµŒå…¥å¼æ§åˆ¶"><meta property="og:image" content="https://images.unsplash.com/photo-1581091226825-a6a2a5aee158?w=800&amp;h=400&amp;fit=crop"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.unsplash.com/photo-1581091226825-a6a2a5aee158?w=800&amp;h=400&amp;fit=crop"><meta name=twitter:title content="æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒ"><meta name=twitter:description content='ğŸ”§ é¡¹ç›®æ¦‚è¿°
è¿™æ˜¯ä¸€ä¸ªåŸºäºSTM32F4ç³»åˆ—å¾®æ§åˆ¶å™¨çš„æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒï¼Œä¸“é—¨ç”¨äºå·¥ä¸šç°åœºçš„æ•°æ®é‡‡é›†ã€è®¾å¤‡æ§åˆ¶å’Œæ•°æ®é€šä¿¡ã€‚è¯¥æ§åˆ¶å•å…ƒé›†æˆäº†å¤šç§å·¥ä¸šä¼ æ„Ÿå™¨ï¼Œæ”¯æŒModbus RTU/TCPé€šä¿¡åè®®ï¼Œå¯ä½œä¸ºPLCç³»ç»Ÿçš„è¡¥å……æ§åˆ¶å™¨æˆ–ç‹¬ç«‹çš„ç›‘æ§èŠ‚ç‚¹ä½¿ç”¨ã€‚
ğŸ¯ é¡¹ç›®ç›®æ ‡

å®ç°å¤šä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†å’Œé¢„å¤„ç†
æä¾›æœ¬åœ°æ§åˆ¶å’Œä¿æŠ¤åŠŸèƒ½
æ”¯æŒModbuså·¥ä¸šé€šä¿¡åè®®
å…·å¤‡æ•°æ®è®°å½•å’Œæ•…éšœè¯Šæ–­èƒ½åŠ›
æ»¡è¶³å·¥ä¸šç¯å¢ƒçš„å¯é æ€§è¦æ±‚

ğŸ”§ ç¡¬ä»¶æ¶æ„
STM32æ§åˆ¶æ¿è®¾è®¡
ç¡¬ä»¶é…ç½®:
ä¸»æ§åˆ¶å™¨:
â”œâ”€â”€ STM32F407VGT6 (ARM Cortex-M4, 168MHz)
â”œâ”€â”€ 1MB Flash, 192KB RAM
â”œâ”€â”€ 3Ã—UART (é€šä¿¡æ¥å£)
â”œâ”€â”€ 2Ã—I2C (ä¼ æ„Ÿå™¨æ‰©å±•)
â”œâ”€â”€ 3Ã—SPI (é«˜é€Ÿæ•°æ®æ¥å£)
â”œâ”€â”€ 16Ã—12ä½ADC (æ¨¡æ‹Ÿé‡é‡‡é›†)
â””â”€â”€ 2Ã—12ä½DAC (æ¨¡æ‹Ÿé‡è¾“å‡º)

ç”µæºç®¡ç†:
â”œâ”€â”€ 24V DCå·¥ä¸šç”µæºè¾“å…¥
â”œâ”€â”€ 5V/3.3V DC-DCè½¬æ¢å™¨
â”œâ”€â”€ ç”µæºæ»¤æ³¢å’Œä¿æŠ¤ç”µè·¯
â”œâ”€â”€ å¤‡ç”¨ç”µæ±  (RTCå’Œæ•°æ®ä¿æŒ)
â””â”€â”€ çœ‹é—¨ç‹—å®šæ—¶å™¨

é€šä¿¡æ¥å£:
â”œâ”€â”€ RS485æ¥å£ (Modbus RTU)
â”œâ”€â”€ Ethernetæ¥å£ (Modbus TCP)
â”œâ”€â”€ USBæ¥å£ (è°ƒè¯•å’Œé…ç½®)
â”œâ”€â”€ CANæ€»çº¿æ¥å£ (è®¾å¤‡äº’è”)
â””â”€â”€ WiFiæ¨¡å— (å¯é€‰æ— çº¿é€šä¿¡)
ä¼ æ„Ÿå™¨æ¥å£ç”µè·¯
ä¼ æ„Ÿå™¨è¿æ¥:
â”œâ”€â”€ æ¸©åº¦ä¼ æ„Ÿå™¨ (PT100)
â”‚   â”œâ”€â”€ æ’æµæºæ¿€åŠ±ç”µè·¯
â”‚   â”œâ”€â”€ ä¿¡å·æ”¾å¤§å’Œæ»¤æ³¢
â”‚   â””â”€â”€ å†·ç«¯è¡¥å¿
â”œâ”€â”€ å‹åŠ›ä¼ æ„Ÿå™¨ (4-20mA)
â”‚   â”œâ”€â”€ ç²¾å¯†ç”µé˜»é‡‡æ ·
â”‚   â”œâ”€â”€ è¿‡å‹ä¿æŠ¤
â”‚   â””â”€â”€ ä¿¡å·éš”ç¦»
â”œâ”€â”€ æµé‡è®¡ (è„‰å†²è¾“å‡º)
â”‚   â”œâ”€â”€ å…‰ç”µéš”ç¦»è¾“å…¥
â”‚   â”œâ”€â”€ é¢‘ç‡æµ‹é‡ç”µè·¯
â”‚   â””â”€â”€ æŠ—å¹²æ‰°æ»¤æ³¢
â””â”€â”€ æŒ¯åŠ¨ä¼ æ„Ÿå™¨ (IEPE)
    â”œâ”€â”€ æ’æµæºä¾›ç”µ
    â”œâ”€â”€ ACä¿¡å·æ”¾å¤§
    â””â”€â”€ RMSè½¬æ¢ç”µè·¯
ğŸ’» è½¯ä»¶æ¶æ„
ä¸»ç¨‹åºæ¡†æ¶
/**
 * @file main.c
 * @brief æ™ºèƒ½æ§åˆ¶å•å…ƒä¸»ç¨‹åº
 * @author Automation Technician
 * @date 2025-11-12
 */

#include "main.h"
#include "sensor_manager.h"
#include "modbus_server.h"
#include "data_logger.h"
#include "watchdog.h"
#include "system_config.h"

/* å…¨å±€å˜é‡å®šä¹‰ */
SystemStatus_t g_systemStatus;
SensorData_t g_sensorData;
ModbusRegisters_t g_modbusRegisters;
uint32_t g_systemTick = 0;

/* å‡½æ•°å£°æ˜ */
static void SystemClock_Config(void);
static void GPIO_Init(void);
static void Peripherals_Init(void);
static void Task_SensorAcquisition(void);
static void Task_DataProcessing(void);
static void Task_Communication(void);
static void Task_SystemMonitoring(void);

/**
 * @brief ä¸»å‡½æ•°
 */
int main(void)
{
    /* ç³»ç»Ÿåˆå§‹åŒ– */
    HAL_Init();
    SystemClock_Config();
    GPIO_Init();
    Peripherals_Init();

    /* å¤–è®¾åˆå§‹åŒ– */
    SensorManager_Init();
    ModbusServer_Init();
    DataLogger_Init();
    Watchdog_Init();

    /* ç³»ç»ŸçŠ¶æ€åˆå§‹åŒ– */
    g_systemStatus.mode = MODE_AUTO;
    g_systemStatus.error_code = ERROR_NONE;
    g_systemStatus.uptime = 0;

    /* ä¸»å¾ªç¯ */
    while (1)
    {
        g_systemTick = HAL_GetTick();

        /* ä»»åŠ¡è°ƒåº¦ */
        Task_SensorAcquisition();    // 100mså‘¨æœŸ
        Task_DataProcessing();       // 500mså‘¨æœŸ
        Task_Communication();        // å®æ—¶å¤„ç†
        Task_SystemMonitoring();     // 1000mså‘¨æœŸ

        /* å–‚ç‹— */
        Watchdog_Refresh();

        /* ä½åŠŸè€—å¤„ç† */
        if (g_systemStatus.mode == MODE_SLEEP) {
            __WFI();
        }
    }
}

/**
 * @brief ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†ä»»åŠ¡
 */
static void Task_SensorAcquisition(void)
{
    static uint32_t lastAcquisitionTime = 0;

    /* 100msé‡‡é›†å‘¨æœŸ */
    if (g_systemTick - lastAcquisitionTime >= 100) {

        /* é‡‡é›†æ¸©åº¦æ•°æ® */
        g_sensorData.temperature = SensorManager_ReadTemperature();

        /* é‡‡é›†å‹åŠ›æ•°æ® */
        g_sensorData.pressure = SensorManager_ReadPressure();

        /* é‡‡é›†æµé‡æ•°æ® */
        g_sensorData.flow_rate = SensorManager_ReadFlowRate();

        /* é‡‡é›†æŒ¯åŠ¨æ•°æ® */
        g_sensorData.vibration = SensorManager_ReadVibration();

        /* æ›´æ–°æ•°æ®æ—¶é—´æˆ³ */
        g_sensorData.timestamp = g_systemTick;

        lastAcquisitionTime = g_systemTick;
    }
}

/**
 * @brief æ•°æ®å¤„ç†ä»»åŠ¡
 */
static void Task_DataProcessing(void)
{
    static uint32_t lastProcessingTime = 0;

    /* 500mså¤„ç†å‘¨æœŸ */
    if (g_systemTick - lastProcessingTime >= 500) {

        /* æ•°æ®æ»¤æ³¢å¤„ç† */
        DataLogger_FilterSensorData(&amp;g_sensorData);

        /* æ•°æ®èŒƒå›´æ£€æŸ¥ */
        DataLogger_ValidateSensorData(&amp;g_sensorData);

        /* è®¡ç®—è¡ç”Ÿå‚æ•° */
        g_sensorData.pressure_rate = DataLogger_CalculatePressureRate();
        g_sensorData.flow_total = DataLogger_CalculateFlowTotal();

        /* æ›´æ–°Modbuså¯„å­˜å™¨ */
        ModbusServer_UpdateRegisters(&amp;g_sensorData);

        lastProcessingTime = g_systemTick;
    }
}

/**
 * @brief é€šä¿¡å¤„ç†ä»»åŠ¡
 */
static void Task_Communication(void)
{
    /* Modbus RTUé€šä¿¡å¤„ç† */
    if (HAL_UART_GetState(&amp;huart1) == HAL_UART_STATE_BUSY_RX) {
        ModbusServer_ProcessRTU();
    }

    /* Modbus TCPé€šä¿¡å¤„ç† */
    if (HAL_ETH_GetState(&amp;heth) == HAL_ETH_STATE_BUSY_RX) {
        ModbusServer_ProcessTCP();
    }

    /* USBé€šä¿¡å¤„ç† (è°ƒè¯•ç”¨) */
    if (HAL_UART_GetState(&amp;huart3) == HAL_UART_STATE_BUSY_RX) {
        ProcessUSBCommand();
    }
}

/**
 * @brief ç³»ç»Ÿç›‘æ§ä»»åŠ¡
 */
static void Task_SystemMonitoring(void)
{
    static uint32_t lastMonitorTime = 0;

    /* 1000msç›‘æ§å‘¨æœŸ */
    if (g_systemTick - lastMonitorTime >= 1000) {

        /* æ›´æ–°ç³»ç»Ÿè¿è¡Œæ—¶é—´ */
        g_systemStatus.uptime++;

        /* æ£€æŸ¥ç³»ç»Ÿé”™è¯¯ */
        SystemError_Check();

        /* ç›‘æ§ç”µæºç”µå‹ */
        if (SystemMonitor_GetPowerVoltage() < 20.0) {
            g_systemStatus.error_code |= ERROR_LOW_VOLTAGE;
        }

        /* æ£€æŸ¥å­˜å‚¨ç©ºé—´ */
        if (DataLogger_GetFreeSpace() < 1024) {
            g_systemStatus.error_code |= ERROR_STORAGE_FULL;
        }

        /* ç³»ç»ŸçŠ¶æ€LEDæŒ‡ç¤º */
        SystemStatus_UpdateLED();

        lastMonitorTime = g_systemTick;
    }
}
ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å—
/**
 * @file sensor_manager.c
 * @brief ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å—
 */

#include "sensor_manager.h"
#include "adc.h"
#include "tim.h"
#include "i2c.h"

/* ä¼ æ„Ÿå™¨æ ¡å‡†å‚æ•° */
typedef struct {
    float offset;
    float scale;
    float filter_coefficient;
} SensorCalibration_t;

static SensorCalibration_t tempCalib = {0.0, 1.0, 0.1};
static SensorCalibration_t pressureCalib = {0.0, 1.0, 0.1};

/**
 * @brief æ¸©åº¦ä¼ æ„Ÿå™¨è¯»å– (PT100)
 */
float SensorManager_ReadTemperature(void)
{
    static float filteredTemp = 25.0;
    uint16_t adcValue;
    float voltage, resistance, temperature;

    /* è¯»å–ADCå€¼ */
    adcValue = ADC_ReadChannel(ADC_CHANNEL_TEMP);

    /* è½¬æ¢ä¸ºç”µå‹ */
    voltage = (float)adcValue * 3.3f / 4096.0f;

    /* è®¡ç®—PT100ç”µé˜» */
    resistance = voltage * 1000.0f / 1.0f; /* 1mAæ’æµæº */

    /* PT100ç”µé˜»-æ¸©åº¦è½¬æ¢ (Callendar-Van Dusenæ–¹ç¨‹) */
    if (resistance >= 100.0) {
        temperature = -242.02 + 2.2228 * resistance
                   + 0.00258 * resistance * resistance;
    } else {
        temperature = -242.02 + 2.2228 * resistance;
    }

    /* åº”ç”¨æ ¡å‡†å‚æ•° */
    temperature = temperature * tempCalib.scale + tempCalib.offset;

    /* è½¯ä»¶æ»¤æ³¢ */
    filteredTemp = filteredTemp * (1.0 - tempCalib.filter_coefficient)
                + temperature * tempCalib.filter_coefficient;

    return filteredTemp;
}

/**
 * @brief å‹åŠ›ä¼ æ„Ÿå™¨è¯»å– (4-20mA)
 */
float SensorManager_ReadPressure(void)
{
    static float filteredPressure = 0.0;
    uint16_t adcValue;
    float current, pressure;

    /* è¯»å–ADCå€¼ */
    adcValue = ADC_ReadChannel(ADC_CHANNEL_PRESSURE);

    /* è½¬æ¢ä¸ºç”µæµ (4-20mAå¯¹åº”0.8-4Vç”µå‹) */
    float voltage = (float)adcValue * 3.3f / 4096.0f;
    current = (voltage - 0.8f) * 5.0f; /* 4-20mA */

    /* è½¬æ¢ä¸ºå‹åŠ›å€¼ (0-10Bar) */
    pressure = (current - 4.0f) * 10.0f / 16.0f; /* 4-20mA -> 0-10Bar */

    /* è´Ÿå€¼å¤„ç† */
    if (pressure < 0.0) pressure = 0.0;

    /* åº”ç”¨æ ¡å‡†å‚æ•° */
    pressure = pressure * pressureCalib.scale + pressureCalib.offset;

    /* è½¯ä»¶æ»¤æ³¢ */
    filteredPressure = filteredPressure * (1.0 - pressureCalib.filter_coefficient)
                     + pressure * pressureCalib.filter_coefficient;

    return filteredPressure;
}

/**
 * @brief æµé‡ä¼ æ„Ÿå™¨è¯»å– (è„‰å†²è¾“å‡º)
 */
float SensorManager_ReadFlowRate(void)
{
    static uint32_t lastPulseCount = 0;
    static uint32_t lastReadTime = 0;
    static float flowRate = 0.0;

    uint32_t currentPulseCount, pulseDelta;
    uint32_t timeDelta;
    float frequency;

    /* è·å–å½“å‰è„‰å†²è®¡æ•° */
    currentPulseCount = TIM_GetPulseCount(TIM_FLOW);

    /* è®¡ç®—æ—¶é—´å·® */
    timeDelta = g_systemTick - lastReadTime;
    if (timeDelta > 0) {
        /* è®¡ç®—è„‰å†²å¢é‡ */
        pulseDelta = currentPulseCount - lastPulseCount;

        /* è®¡ç®—é¢‘ç‡ (Hz) */
        frequency = (float)pulseDelta * 1000.0f / (float)timeDelta;

        /* è½¬æ¢ä¸ºæµé‡ (L/min) */
        flowRate = frequency * 60.0f / 100.0f; /* 100è„‰å†²/L */

        /* æ›´æ–°å†å²è®°å½• */
        lastPulseCount = currentPulseCount;
        lastReadTime = g_systemTick;
    }

    return flowRate;
}

/**
 * @brief æŒ¯åŠ¨ä¼ æ„Ÿå™¨è¯»å– (IEPE)
 */
float SensorManager_ReadVibration(void)
{
    uint16_t adcValue;
    float voltage, rmsValue;

    /* è¯»å–ADCå€¼ */
    adcValue = ADC_ReadChannel(ADC_CHANNEL_VIBRATION);

    /* è½¬æ¢ä¸ºç”µå‹ */
    voltage = (float)adcValue * 3.3f / 4096.0f;

    /* è®¡ç®—RMSå€¼ */
    rmsValue = Vibration_CalculateRMS(voltage);

    /* è½¬æ¢ä¸ºåŠ é€Ÿåº¦å€¼ (g) */
    float acceleration = rmsValue * 10.0f; /* 10g/Vçµæ•åº¦ */

    return acceleration;
}
Modbusé€šä¿¡æ¨¡å—
/**
 * @file modbus_server.c
 * @brief ModbusæœåŠ¡å™¨å®ç°
 */

#include "modbus_server.h"
#include "usart.h"
#include "ethernet.h"

/* Modbuså¯„å­˜å™¨æ˜ å°„ */
typedef union {
    struct {
        uint16_t holding_registers[100];
        uint16_t input_registers[100];
        uint16_t coils[100];
        uint16_t discrete_inputs[100];
    } registers;
    uint16_t raw[400];
} ModbusMemoryMap_t;

static ModbusMemoryMap_t g_modbusMemory;

/**
 * @brief Modbuså¯„å­˜å™¨æ˜ å°„
 */
void ModbusServer_UpdateRegisters(SensorData_t* sensorData)
{
    /* è¾“å…¥å¯„å­˜å™¨ (åªè¯») */
    g_modbusMemory.registers.input_registers[0] =
        (uint16_t)(sensorData->temperature * 10.0);  // æ¸©åº¦ (0.1Â°C)
    g_modbusMemory.registers.input_registers[1] =
        (uint16_t)(sensorData->pressure * 100.0);    // å‹åŠ› (0.01Bar)
    g_modbusMemory.registers.input_registers[2] =
        (uint16_t)(sensorData->flow_rate * 10.0);    // æµé‡ (0.1L/min)
    g_modbusMemory.registers.input_registers[3] =
        (uint16_t)(sensorData->vibration * 100.0);   // æŒ¯åŠ¨ (0.01g)

    /* ä¿æŒå¯„å­˜å™¨ (è¯»å†™) */
    g_modbusMemory.registers.holding_registers[0] =
        (uint16_t)(g_systemStatus.mode);            // è¿è¡Œæ¨¡å¼
    g_modbusMemory.registers.holding_registers[1] =
        (uint16_t)(g_systemStatus.error_code);      // é”™è¯¯ä»£ç 
    g_modbusMemory.registers.holding_registers[2] =
        (uint16_t)(g_systemStatus.uptime);          // è¿è¡Œæ—¶é—´
}

/**
 * @brief å¤„ç†Modbus RTUè¯·æ±‚
 */
void ModbusServer_ProcessRTU(void)
{
    static uint8_t rxBuffer[256];
    static uint8_t txBuffer[256];
    uint16_t rxLength, txLength;

    /* æ¥æ”¶æ•°æ® */
    if (UART_ReceiveBuffer(&amp;huart1, rxBuffer, &amp;rxLength)) {

        /* è§£æModbusè¯·æ±‚ */
        ModbusRequest_t request;
        if (Modbus_ParseRequest(rxBuffer, rxLength, &amp;request)) {

            /* å¤„ç†è¯·æ±‚ */
            ModbusResponse_t response;
            Modbus_ProcessRequest(&amp;request, &amp;response);

            /* ç”Ÿæˆå“åº”å¸§ */
            txLength = Modbus_GenerateResponse(&amp;response, txBuffer);

            /* å‘é€å“åº” */
            UART_Transmit(&amp;huart1, txBuffer, txLength);
        }
    }
}

/**
 * @brief å¤„ç†Modbus TCPè¯·æ±‚
 */
void ModbusServer_ProcessTCP(void)
{
    /* TCPé€šä¿¡å¤„ç† (ç®€åŒ–å®ç°) */
    uint8_t tcpBuffer[512];
    uint16_t tcpLength;

    if (Ethernet_ReceiveData(tcpBuffer, &amp;tcpLength)) {
        /* è§£æMBAPå¤´éƒ¨å’ŒModbus PDU */
        ModbusTCP_Request_t tcpRequest;
        if (ModbusTCP_ParseRequest(tcpBuffer, tcpLength, &amp;tcpRequest)) {

            /* å¤„ç†Modbusè¯·æ±‚ */
            ModbusResponse_t response;
            Modbus_ProcessRequest(&amp;tcpRequest.modbus_request, &amp;response);

            /* ç”ŸæˆTCPå“åº” */
            uint16_t responseLength;
            responseLength = ModbusTCP_GenerateResponse(
                &amp;tcpRequest, &amp;response, tcpBuffer);

            /* å‘é€TCPå“åº” */
            Ethernet_TransmitData(tcpBuffer, responseLength);
        }
    }
}

/**
 * @brief å¤„ç†ModbusåŠŸèƒ½ç 
 */
void Modbus_ProcessRequest(ModbusRequest_t* request, ModbusResponse_t* response)
{
    response->slave_address = request->slave_address;
    response->function_code = request->function_code;

    switch (request->function_code) {
        case MODBUS_FC_READ_HOLDING_REGISTERS:
            Modbus_ReadHoldingRegisters(request, response);
            break;

        case MODBUS_FC_READ_INPUT_REGISTERS:
            Modbus_ReadInputRegisters(request, response);
            break;

        case MODBUS_FC_WRITE_SINGLE_REGISTER:
            Modbus_WriteSingleRegister(request, response);
            break;

        case MODBUS_FC_WRITE_MULTIPLE_REGISTERS:
            Modbus_WriteMultipleRegisters(request, response);
            break;

        default:
            response->function_code |= 0x80; // å¼‚å¸¸å“åº”
            response->data[0] = MODBUS_EXCEPTION_ILLEGAL_FUNCTION;
            response->data_length = 1;
            break;
    }
}
ğŸ“Š æ•°æ®è®°å½•ä¸åˆ†æ
æ•°æ®è®°å½•åŠŸèƒ½
/**
 * @file data_logger.c
 * @brief æ•°æ®è®°å½•æ¨¡å—
 */

#include "data_logger.h"
#include "flash.h"
#include "rtc.h"

/* æ•°æ®è®°å½•ç»“æ„ */
typedef struct {
    uint32_t timestamp;
    float temperature;
    float pressure;
    float flow_rate;
    float vibration;
    uint16_t system_status;
} DataRecord_t;

/* å†å²æ•°æ®ç¼“å†²åŒº */
#define DATA_BUFFER_SIZE  1000
static DataRecord_t g_dataBuffer[DATA_BUFFER_SIZE];
static uint16_t g_dataBufferIndex = 0;
static uint32_t g_totalRecords = 0;

/**
 * @brief è®°å½•ä¼ æ„Ÿå™¨æ•°æ®
 */
void DataLogger_RecordData(SensorData_t* sensorData)
{
    DataRecord_t* record = &amp;g_dataBuffer[g_dataBufferIndex];

    /* å¡«å……æ•°æ®è®°å½• */
    record->timestamp = RTC_GetTimestamp();
    record->temperature = sensorData->temperature;
    record->pressure = sensorData->pressure;
    record->flow_rate = sensorData->flow_rate;
    record->vibration = sensorData->vibration;
    record->system_status = g_systemStatus.error_code;

    /* æ›´æ–°ç¼“å†²åŒºç´¢å¼• */
    g_dataBufferIndex = (g_dataBufferIndex + 1) % DATA_BUFFER_SIZE;
    g_totalRecords++;

    /* æ£€æŸ¥æ˜¯å¦éœ€è¦ä¿å­˜åˆ°Flash */
    if (g_dataBufferIndex % 100 == 0) {
        DataLogger_SaveToFlash();
    }
}

/**
 * @brief æ•°æ®æ»¤æ³¢å¤„ç†
 */
void DataLogger_FilterSensorData(SensorData_t* sensorData)
{
    static SensorData_t filterBuffer[5];
    static uint8_t filterIndex = 0;

    /* æ›´æ–°æ»¤æ³¢ç¼“å†²åŒº */
    filterBuffer[filterIndex] = *sensorData;
    filterIndex = (filterIndex + 1) % 5;

    /* è®¡ç®—ç§»åŠ¨å¹³å‡å€¼ */
    float tempSum = 0.0, pressureSum = 0.0;
    float flowSum = 0.0, vibrationSum = 0.0;

    for (int i = 0; i < 5; i++) {
        tempSum += filterBuffer[i].temperature;
        pressureSum += filterBuffer[i].pressure;
        flowSum += filterBuffer[i].flow_rate;
        vibrationSum += filterBuffer[i].vibration;
    }

    sensorData->temperature = tempSum / 5.0;
    sensorData->pressure = pressureSum / 5.0;
    sensorData->flow_rate = flowSum / 5.0;
    sensorData->vibration = vibrationSum / 5.0;
}

/**
 * @brief æ•°æ®æœ‰æ•ˆæ€§æ£€æŸ¥
 */
bool DataLogger_ValidateSensorData(SensorData_t* sensorData)
{
    bool isValid = true;

    /* æ¸©åº¦èŒƒå›´æ£€æŸ¥ */
    if (sensorData->temperature < -40.0 || sensorData->temperature > 125.0) {
        sensorData->temperature = 25.0; // é»˜è®¤å€¼
        isValid = false;
    }

    /* å‹åŠ›èŒƒå›´æ£€æŸ¥ */
    if (sensorData->pressure < 0.0 || sensorData->pressure > 20.0) {
        sensorData->pressure = 0.0;
        isValid = false;
    }

    /* æµé‡èŒƒå›´æ£€æŸ¥ */
    if (sensorData->flow_rate < 0.0 || sensorData->flow_rate > 1000.0) {
        sensorData->flow_rate = 0.0;
        isValid = false;
    }

    /* æŒ¯åŠ¨èŒƒå›´æ£€æŸ¥ */
    if (sensorData->vibration < 0.0 || sensorData->vibration > 50.0) {
        sensorData->vibration = 0.0;
        isValid = false;
    }

    return isValid;
}
ğŸ”§ ç³»ç»Ÿæµ‹è¯•ä¸éªŒè¯
åŠŸèƒ½æµ‹è¯•æ¸…å•
ç¡¬ä»¶æµ‹è¯•:
âœ“ ç”µæºè¾“å…¥æµ‹è¯• (24V DC Â±10%)
âœ“ å·¥ä½œæ¸©åº¦æµ‹è¯• (-20Â°C ~ +70Â°C)
âœ“ EMIæŠ—å¹²æ‰°æµ‹è¯• (IEC 61000-4-3)
âœ“ é˜²æŠ¤ç­‰çº§æµ‹è¯• (IP65)
âœ“ æŒ¯åŠ¨æµ‹è¯• (IEC 60068-2-6)

è½¯ä»¶æµ‹è¯•:
âœ“ ä¼ æ„Ÿå™¨ç²¾åº¦æµ‹è¯• (Â±0.1%)
âœ“ Modbusé€šä¿¡æµ‹è¯• (RTU/TCP)
âœ“ æ•°æ®è®°å½•æµ‹è¯• (1000æ¡/ç§’)
âœ“ çœ‹é—¨ç‹—åŠŸèƒ½æµ‹è¯•
âœ“ æ•…éšœæ¢å¤æµ‹è¯•

æ€§èƒ½æŒ‡æ ‡:
âœ“ å¯åŠ¨æ—¶é—´: < 2ç§’
âœ“ æ•°æ®æ›´æ–°é¢‘ç‡: 10Hz
âœ“ é€šä¿¡å“åº”æ—¶é—´: < 100ms
âœ“ å­˜å‚¨å®¹é‡: 10,000æ¡è®°å½•
âœ“ åŠŸè€—: < 5W
ç°åœºæµ‹è¯•ç»“æœ
æµ‹è¯•ç¯å¢ƒ: å·¥ä¸šæ³µç«™ç°åœº
æµ‹è¯•æ—¶é—´: 72å°æ—¶è¿ç»­è¿è¡Œ

ä¼ æ„Ÿå™¨æµ‹è¯•ç»“æœ:
- æ¸©åº¦æµ‹é‡ç²¾åº¦: Â±0.05Â°C (PT100, 0-100Â°CèŒƒå›´)
- å‹åŠ›æµ‹é‡ç²¾åº¦: Â±0.2%FS (4-20mA, 0-10Bar)
- æµé‡æµ‹é‡ç²¾åº¦: Â±1.0% (è„‰å†²è¾“å‡º, 0-500L/min)
- æŒ¯åŠ¨æµ‹é‡ç²¾åº¦: Â±5% (IEPE, 0-10g)

é€šä¿¡æµ‹è¯•ç»“æœ:
- Modbus RTU: 9600bps, 0é”™è¯¯
- Modbus TCP: 100Mbps, <10mså»¶è¿Ÿ
- æ•°æ®å®Œæ•´æ€§: 99.99%
- è¿æ¥ç¨³å®šæ€§: 72å°æ—¶æ— æ–­çº¿

ç³»ç»Ÿç¨³å®šæ€§:
- è¿ç»­è¿è¡Œæ—¶é—´: 72å°æ—¶
- å†…å­˜ä½¿ç”¨ç‡: 45%
- CPUä½¿ç”¨ç‡: 30%
- å­˜å‚¨ç©ºé—´ä½¿ç”¨: 23%
ğŸ“ˆ é¡¹ç›®åº”ç”¨åœºæ™¯
å·¥ä¸šåº”ç”¨æ¡ˆä¾‹


æ³µç«™ç›‘æ§ç³»ç»Ÿ'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Projects","item":"https://hugo-maker-blog.vercel.app/projects/"},{"@type":"ListItem","position":2,"name":"æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒ","item":"https://hugo-maker-blog.vercel.app/projects/embedded-control-unit/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒ","name":"æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒ","description":"ğŸ”§ é¡¹ç›®æ¦‚è¿° è¿™æ˜¯ä¸€ä¸ªåŸºäºSTM32F4ç³»åˆ—å¾®æ§åˆ¶å™¨çš„æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒï¼Œä¸“é—¨ç”¨äºå·¥ä¸šç°åœºçš„æ•°æ®é‡‡é›†ã€è®¾å¤‡æ§åˆ¶å’Œæ•°æ®é€šä¿¡ã€‚è¯¥æ§åˆ¶å•å…ƒé›†æˆäº†å¤šç§å·¥ä¸šä¼ æ„Ÿå™¨ï¼Œæ”¯æŒModbus RTU/TCPé€šä¿¡åè®®ï¼Œå¯ä½œä¸ºPLCç³»ç»Ÿçš„è¡¥å……æ§åˆ¶å™¨æˆ–ç‹¬ç«‹çš„ç›‘æ§èŠ‚ç‚¹ä½¿ç”¨ã€‚\nğŸ¯ é¡¹ç›®ç›®æ ‡ å®ç°å¤šä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†å’Œé¢„å¤„ç† æä¾›æœ¬åœ°æ§åˆ¶å’Œä¿æŠ¤åŠŸèƒ½ æ”¯æŒModbuså·¥ä¸šé€šä¿¡åè®® å…·å¤‡æ•°æ®è®°å½•å’Œæ•…éšœè¯Šæ–­èƒ½åŠ› æ»¡è¶³å·¥ä¸šç¯å¢ƒçš„å¯é æ€§è¦æ±‚ ğŸ”§ ç¡¬ä»¶æ¶æ„ STM32æ§åˆ¶æ¿è®¾è®¡ ç¡¬ä»¶é…ç½®: ä¸»æ§åˆ¶å™¨: â”œâ”€â”€ STM32F407VGT6 (ARM Cortex-M4, 168MHz) â”œâ”€â”€ 1MB Flash, 192KB RAM â”œâ”€â”€ 3Ã—UART (é€šä¿¡æ¥å£) â”œâ”€â”€ 2Ã—I2C (ä¼ æ„Ÿå™¨æ‰©å±•) â”œâ”€â”€ 3Ã—SPI (é«˜é€Ÿæ•°æ®æ¥å£) â”œâ”€â”€ 16Ã—12ä½ADC (æ¨¡æ‹Ÿé‡é‡‡é›†) â””â”€â”€ 2Ã—12ä½DAC (æ¨¡æ‹Ÿé‡è¾“å‡º) ç”µæºç®¡ç†: â”œâ”€â”€ 24V DCå·¥ä¸šç”µæºè¾“å…¥ â”œâ”€â”€ 5V/3.3V DC-DCè½¬æ¢å™¨ â”œâ”€â”€ ç”µæºæ»¤æ³¢å’Œä¿æŠ¤ç”µè·¯ â”œâ”€â”€ å¤‡ç”¨ç”µæ±  (RTCå’Œæ•°æ®ä¿æŒ) â””â”€â”€ çœ‹é—¨ç‹—å®šæ—¶å™¨ é€šä¿¡æ¥å£: â”œâ”€â”€ RS485æ¥å£ (Modbus RTU) â”œâ”€â”€ Ethernetæ¥å£ (Modbus TCP) â”œâ”€â”€ USBæ¥å£ (è°ƒè¯•å’Œé…ç½®) â”œâ”€â”€ CANæ€»çº¿æ¥å£ (è®¾å¤‡äº’è”) â””â”€â”€ WiFiæ¨¡å— (å¯é€‰æ— çº¿é€šä¿¡) ä¼ æ„Ÿå™¨æ¥å£ç”µè·¯ ä¼ æ„Ÿå™¨è¿æ¥: â”œâ”€â”€ æ¸©åº¦ä¼ æ„Ÿå™¨ (PT100) â”‚ â”œâ”€â”€ æ’æµæºæ¿€åŠ±ç”µè·¯ â”‚ â”œâ”€â”€ ä¿¡å·æ”¾å¤§å’Œæ»¤æ³¢ â”‚ â””â”€â”€ å†·ç«¯è¡¥å¿ â”œâ”€â”€ å‹åŠ›ä¼ æ„Ÿå™¨ (4-20mA) â”‚ â”œâ”€â”€ ç²¾å¯†ç”µé˜»é‡‡æ · â”‚ â”œâ”€â”€ è¿‡å‹ä¿æŠ¤ â”‚ â””â”€â”€ ä¿¡å·éš”ç¦» â”œâ”€â”€ æµé‡è®¡ (è„‰å†²è¾“å‡º) â”‚ â”œâ”€â”€ å…‰ç”µéš”ç¦»è¾“å…¥ â”‚ â”œâ”€â”€ é¢‘ç‡æµ‹é‡ç”µè·¯ â”‚ â””â”€â”€ æŠ—å¹²æ‰°æ»¤æ³¢ â””â”€â”€ æŒ¯åŠ¨ä¼ æ„Ÿå™¨ (IEPE) â”œâ”€â”€ æ’æµæºä¾›ç”µ â”œâ”€â”€ ACä¿¡å·æ”¾å¤§ â””â”€â”€ RMSè½¬æ¢ç”µè·¯ ğŸ’» è½¯ä»¶æ¶æ„ ä¸»ç¨‹åºæ¡†æ¶ /** * @file main.c * @brief æ™ºèƒ½æ§åˆ¶å•å…ƒä¸»ç¨‹åº * @author Automation Technician * @date 2025-11-12 */ #include \u0026#34;main.h\u0026#34; #include \u0026#34;sensor_manager.h\u0026#34; #include \u0026#34;modbus_server.h\u0026#34; #include \u0026#34;data_logger.h\u0026#34; #include \u0026#34;watchdog.h\u0026#34; #include \u0026#34;system_config.h\u0026#34; /* å…¨å±€å˜é‡å®šä¹‰ */ SystemStatus_t g_systemStatus; SensorData_t g_sensorData; ModbusRegisters_t g_modbusRegisters; uint32_t g_systemTick = 0; /* å‡½æ•°å£°æ˜ */ static void SystemClock_Config(void); static void GPIO_Init(void); static void Peripherals_Init(void); static void Task_SensorAcquisition(void); static void Task_DataProcessing(void); static void Task_Communication(void); static void Task_SystemMonitoring(void); /** * @brief ä¸»å‡½æ•° */ int main(void) { /* ç³»ç»Ÿåˆå§‹åŒ– */ HAL_Init(); SystemClock_Config(); GPIO_Init(); Peripherals_Init(); /* å¤–è®¾åˆå§‹åŒ– */ SensorManager_Init(); ModbusServer_Init(); DataLogger_Init(); Watchdog_Init(); /* ç³»ç»ŸçŠ¶æ€åˆå§‹åŒ– */ g_systemStatus.mode = MODE_AUTO; g_systemStatus.error_code = ERROR_NONE; g_systemStatus.uptime = 0; /* ä¸»å¾ªç¯ */ while (1) { g_systemTick = HAL_GetTick(); /* ä»»åŠ¡è°ƒåº¦ */ Task_SensorAcquisition(); // 100mså‘¨æœŸ Task_DataProcessing(); // 500mså‘¨æœŸ Task_Communication(); // å®æ—¶å¤„ç† Task_SystemMonitoring(); // 1000mså‘¨æœŸ /* å–‚ç‹— */ Watchdog_Refresh(); /* ä½åŠŸè€—å¤„ç† */ if (g_systemStatus.mode == MODE_SLEEP) { __WFI(); } } } /** * @brief ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†ä»»åŠ¡ */ static void Task_SensorAcquisition(void) { static uint32_t lastAcquisitionTime = 0; /* 100msé‡‡é›†å‘¨æœŸ */ if (g_systemTick - lastAcquisitionTime \u0026gt;= 100) { /* é‡‡é›†æ¸©åº¦æ•°æ® */ g_sensorData.temperature = SensorManager_ReadTemperature(); /* é‡‡é›†å‹åŠ›æ•°æ® */ g_sensorData.pressure = SensorManager_ReadPressure(); /* é‡‡é›†æµé‡æ•°æ® */ g_sensorData.flow_rate = SensorManager_ReadFlowRate(); /* é‡‡é›†æŒ¯åŠ¨æ•°æ® */ g_sensorData.vibration = SensorManager_ReadVibration(); /* æ›´æ–°æ•°æ®æ—¶é—´æˆ³ */ g_sensorData.timestamp = g_systemTick; lastAcquisitionTime = g_systemTick; } } /** * @brief æ•°æ®å¤„ç†ä»»åŠ¡ */ static void Task_DataProcessing(void) { static uint32_t lastProcessingTime = 0; /* 500mså¤„ç†å‘¨æœŸ */ if (g_systemTick - lastProcessingTime \u0026gt;= 500) { /* æ•°æ®æ»¤æ³¢å¤„ç† */ DataLogger_FilterSensorData(\u0026amp;g_sensorData); /* æ•°æ®èŒƒå›´æ£€æŸ¥ */ DataLogger_ValidateSensorData(\u0026amp;g_sensorData); /* è®¡ç®—è¡ç”Ÿå‚æ•° */ g_sensorData.pressure_rate = DataLogger_CalculatePressureRate(); g_sensorData.flow_total = DataLogger_CalculateFlowTotal(); /* æ›´æ–°Modbuså¯„å­˜å™¨ */ ModbusServer_UpdateRegisters(\u0026amp;g_sensorData); lastProcessingTime = g_systemTick; } } /** * @brief é€šä¿¡å¤„ç†ä»»åŠ¡ */ static void Task_Communication(void) { /* Modbus RTUé€šä¿¡å¤„ç† */ if (HAL_UART_GetState(\u0026amp;huart1) == HAL_UART_STATE_BUSY_RX) { ModbusServer_ProcessRTU(); } /* Modbus TCPé€šä¿¡å¤„ç† */ if (HAL_ETH_GetState(\u0026amp;heth) == HAL_ETH_STATE_BUSY_RX) { ModbusServer_ProcessTCP(); } /* USBé€šä¿¡å¤„ç† (è°ƒè¯•ç”¨) */ if (HAL_UART_GetState(\u0026amp;huart3) == HAL_UART_STATE_BUSY_RX) { ProcessUSBCommand(); } } /** * @brief ç³»ç»Ÿç›‘æ§ä»»åŠ¡ */ static void Task_SystemMonitoring(void) { static uint32_t lastMonitorTime = 0; /* 1000msç›‘æ§å‘¨æœŸ */ if (g_systemTick - lastMonitorTime \u0026gt;= 1000) { /* æ›´æ–°ç³»ç»Ÿè¿è¡Œæ—¶é—´ */ g_systemStatus.uptime++; /* æ£€æŸ¥ç³»ç»Ÿé”™è¯¯ */ SystemError_Check(); /* ç›‘æ§ç”µæºç”µå‹ */ if (SystemMonitor_GetPowerVoltage() \u0026lt; 20.0) { g_systemStatus.error_code |= ERROR_LOW_VOLTAGE; } /* æ£€æŸ¥å­˜å‚¨ç©ºé—´ */ if (DataLogger_GetFreeSpace() \u0026lt; 1024) { g_systemStatus.error_code |= ERROR_STORAGE_FULL; } /* ç³»ç»ŸçŠ¶æ€LEDæŒ‡ç¤º */ SystemStatus_UpdateLED(); lastMonitorTime = g_systemTick; } } ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å— /** * @file sensor_manager.c * @brief ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å— */ #include \u0026#34;sensor_manager.h\u0026#34; #include \u0026#34;adc.h\u0026#34; #include \u0026#34;tim.h\u0026#34; #include \u0026#34;i2c.h\u0026#34; /* ä¼ æ„Ÿå™¨æ ¡å‡†å‚æ•° */ typedef struct { float offset; float scale; float filter_coefficient; } SensorCalibration_t; static SensorCalibration_t tempCalib = {0.0, 1.0, 0.1}; static SensorCalibration_t pressureCalib = {0.0, 1.0, 0.1}; /** * @brief æ¸©åº¦ä¼ æ„Ÿå™¨è¯»å– (PT100) */ float SensorManager_ReadTemperature(void) { static float filteredTemp = 25.0; uint16_t adcValue; float voltage, resistance, temperature; /* è¯»å–ADCå€¼ */ adcValue = ADC_ReadChannel(ADC_CHANNEL_TEMP); /* è½¬æ¢ä¸ºç”µå‹ */ voltage = (float)adcValue * 3.3f / 4096.0f; /* è®¡ç®—PT100ç”µé˜» */ resistance = voltage * 1000.0f / 1.0f; /* 1mAæ’æµæº */ /* PT100ç”µé˜»-æ¸©åº¦è½¬æ¢ (Callendar-Van Dusenæ–¹ç¨‹) */ if (resistance \u0026gt;= 100.0) { temperature = -242.02 + 2.2228 * resistance + 0.00258 * resistance * resistance; } else { temperature = -242.02 + 2.2228 * resistance; } /* åº”ç”¨æ ¡å‡†å‚æ•° */ temperature = temperature * tempCalib.scale + tempCalib.offset; /* è½¯ä»¶æ»¤æ³¢ */ filteredTemp = filteredTemp * (1.0 - tempCalib.filter_coefficient) + temperature * tempCalib.filter_coefficient; return filteredTemp; } /** * @brief å‹åŠ›ä¼ æ„Ÿå™¨è¯»å– (4-20mA) */ float SensorManager_ReadPressure(void) { static float filteredPressure = 0.0; uint16_t adcValue; float current, pressure; /* è¯»å–ADCå€¼ */ adcValue = ADC_ReadChannel(ADC_CHANNEL_PRESSURE); /* è½¬æ¢ä¸ºç”µæµ (4-20mAå¯¹åº”0.8-4Vç”µå‹) */ float voltage = (float)adcValue * 3.3f / 4096.0f; current = (voltage - 0.8f) * 5.0f; /* 4-20mA */ /* è½¬æ¢ä¸ºå‹åŠ›å€¼ (0-10Bar) */ pressure = (current - 4.0f) * 10.0f / 16.0f; /* 4-20mA -\u0026gt; 0-10Bar */ /* è´Ÿå€¼å¤„ç† */ if (pressure \u0026lt; 0.0) pressure = 0.0; /* åº”ç”¨æ ¡å‡†å‚æ•° */ pressure = pressure * pressureCalib.scale + pressureCalib.offset; /* è½¯ä»¶æ»¤æ³¢ */ filteredPressure = filteredPressure * (1.0 - pressureCalib.filter_coefficient) + pressure * pressureCalib.filter_coefficient; return filteredPressure; } /** * @brief æµé‡ä¼ æ„Ÿå™¨è¯»å– (è„‰å†²è¾“å‡º) */ float SensorManager_ReadFlowRate(void) { static uint32_t lastPulseCount = 0; static uint32_t lastReadTime = 0; static float flowRate = 0.0; uint32_t currentPulseCount, pulseDelta; uint32_t timeDelta; float frequency; /* è·å–å½“å‰è„‰å†²è®¡æ•° */ currentPulseCount = TIM_GetPulseCount(TIM_FLOW); /* è®¡ç®—æ—¶é—´å·® */ timeDelta = g_systemTick - lastReadTime; if (timeDelta \u0026gt; 0) { /* è®¡ç®—è„‰å†²å¢é‡ */ pulseDelta = currentPulseCount - lastPulseCount; /* è®¡ç®—é¢‘ç‡ (Hz) */ frequency = (float)pulseDelta * 1000.0f / (float)timeDelta; /* è½¬æ¢ä¸ºæµé‡ (L/min) */ flowRate = frequency * 60.0f / 100.0f; /* 100è„‰å†²/L */ /* æ›´æ–°å†å²è®°å½• */ lastPulseCount = currentPulseCount; lastReadTime = g_systemTick; } return flowRate; } /** * @brief æŒ¯åŠ¨ä¼ æ„Ÿå™¨è¯»å– (IEPE) */ float SensorManager_ReadVibration(void) { uint16_t adcValue; float voltage, rmsValue; /* è¯»å–ADCå€¼ */ adcValue = ADC_ReadChannel(ADC_CHANNEL_VIBRATION); /* è½¬æ¢ä¸ºç”µå‹ */ voltage = (float)adcValue * 3.3f / 4096.0f; /* è®¡ç®—RMSå€¼ */ rmsValue = Vibration_CalculateRMS(voltage); /* è½¬æ¢ä¸ºåŠ é€Ÿåº¦å€¼ (g) */ float acceleration = rmsValue * 10.0f; /* 10g/Vçµæ•åº¦ */ return acceleration; } Modbusé€šä¿¡æ¨¡å— /** * @file modbus_server.c * @brief ModbusæœåŠ¡å™¨å®ç° */ #include \u0026#34;modbus_server.h\u0026#34; #include \u0026#34;usart.h\u0026#34; #include \u0026#34;ethernet.h\u0026#34; /* Modbuså¯„å­˜å™¨æ˜ å°„ */ typedef union { struct { uint16_t holding_registers[100]; uint16_t input_registers[100]; uint16_t coils[100]; uint16_t discrete_inputs[100]; } registers; uint16_t raw[400]; } ModbusMemoryMap_t; static ModbusMemoryMap_t g_modbusMemory; /** * @brief Modbuså¯„å­˜å™¨æ˜ å°„ */ void ModbusServer_UpdateRegisters(SensorData_t* sensorData) { /* è¾“å…¥å¯„å­˜å™¨ (åªè¯») */ g_modbusMemory.registers.input_registers[0] = (uint16_t)(sensorData-\u0026gt;temperature * 10.0); // æ¸©åº¦ (0.1Â°C) g_modbusMemory.registers.input_registers[1] = (uint16_t)(sensorData-\u0026gt;pressure * 100.0); // å‹åŠ› (0.01Bar) g_modbusMemory.registers.input_registers[2] = (uint16_t)(sensorData-\u0026gt;flow_rate * 10.0); // æµé‡ (0.1L/min) g_modbusMemory.registers.input_registers[3] = (uint16_t)(sensorData-\u0026gt;vibration * 100.0); // æŒ¯åŠ¨ (0.01g) /* ä¿æŒå¯„å­˜å™¨ (è¯»å†™) */ g_modbusMemory.registers.holding_registers[0] = (uint16_t)(g_systemStatus.mode); // è¿è¡Œæ¨¡å¼ g_modbusMemory.registers.holding_registers[1] = (uint16_t)(g_systemStatus.error_code); // é”™è¯¯ä»£ç  g_modbusMemory.registers.holding_registers[2] = (uint16_t)(g_systemStatus.uptime); // è¿è¡Œæ—¶é—´ } /** * @brief å¤„ç†Modbus RTUè¯·æ±‚ */ void ModbusServer_ProcessRTU(void) { static uint8_t rxBuffer[256]; static uint8_t txBuffer[256]; uint16_t rxLength, txLength; /* æ¥æ”¶æ•°æ® */ if (UART_ReceiveBuffer(\u0026amp;huart1, rxBuffer, \u0026amp;rxLength)) { /* è§£æModbusè¯·æ±‚ */ ModbusRequest_t request; if (Modbus_ParseRequest(rxBuffer, rxLength, \u0026amp;request)) { /* å¤„ç†è¯·æ±‚ */ ModbusResponse_t response; Modbus_ProcessRequest(\u0026amp;request, \u0026amp;response); /* ç”Ÿæˆå“åº”å¸§ */ txLength = Modbus_GenerateResponse(\u0026amp;response, txBuffer); /* å‘é€å“åº” */ UART_Transmit(\u0026amp;huart1, txBuffer, txLength); } } } /** * @brief å¤„ç†Modbus TCPè¯·æ±‚ */ void ModbusServer_ProcessTCP(void) { /* TCPé€šä¿¡å¤„ç† (ç®€åŒ–å®ç°) */ uint8_t tcpBuffer[512]; uint16_t tcpLength; if (Ethernet_ReceiveData(tcpBuffer, \u0026amp;tcpLength)) { /* è§£æMBAPå¤´éƒ¨å’ŒModbus PDU */ ModbusTCP_Request_t tcpRequest; if (ModbusTCP_ParseRequest(tcpBuffer, tcpLength, \u0026amp;tcpRequest)) { /* å¤„ç†Modbusè¯·æ±‚ */ ModbusResponse_t response; Modbus_ProcessRequest(\u0026amp;tcpRequest.modbus_request, \u0026amp;response); /* ç”ŸæˆTCPå“åº” */ uint16_t responseLength; responseLength = ModbusTCP_GenerateResponse( \u0026amp;tcpRequest, \u0026amp;response, tcpBuffer); /* å‘é€TCPå“åº” */ Ethernet_TransmitData(tcpBuffer, responseLength); } } } /** * @brief å¤„ç†ModbusåŠŸèƒ½ç  */ void Modbus_ProcessRequest(ModbusRequest_t* request, ModbusResponse_t* response) { response-\u0026gt;slave_address = request-\u0026gt;slave_address; response-\u0026gt;function_code = request-\u0026gt;function_code; switch (request-\u0026gt;function_code) { case MODBUS_FC_READ_HOLDING_REGISTERS: Modbus_ReadHoldingRegisters(request, response); break; case MODBUS_FC_READ_INPUT_REGISTERS: Modbus_ReadInputRegisters(request, response); break; case MODBUS_FC_WRITE_SINGLE_REGISTER: Modbus_WriteSingleRegister(request, response); break; case MODBUS_FC_WRITE_MULTIPLE_REGISTERS: Modbus_WriteMultipleRegisters(request, response); break; default: response-\u0026gt;function_code |= 0x80; // å¼‚å¸¸å“åº” response-\u0026gt;data[0] = MODBUS_EXCEPTION_ILLEGAL_FUNCTION; response-\u0026gt;data_length = 1; break; } } ğŸ“Š æ•°æ®è®°å½•ä¸åˆ†æ æ•°æ®è®°å½•åŠŸèƒ½ /** * @file data_logger.c * @brief æ•°æ®è®°å½•æ¨¡å— */ #include \u0026#34;data_logger.h\u0026#34; #include \u0026#34;flash.h\u0026#34; #include \u0026#34;rtc.h\u0026#34; /* æ•°æ®è®°å½•ç»“æ„ */ typedef struct { uint32_t timestamp; float temperature; float pressure; float flow_rate; float vibration; uint16_t system_status; } DataRecord_t; /* å†å²æ•°æ®ç¼“å†²åŒº */ #define DATA_BUFFER_SIZE 1000 static DataRecord_t g_dataBuffer[DATA_BUFFER_SIZE]; static uint16_t g_dataBufferIndex = 0; static uint32_t g_totalRecords = 0; /** * @brief è®°å½•ä¼ æ„Ÿå™¨æ•°æ® */ void DataLogger_RecordData(SensorData_t* sensorData) { DataRecord_t* record = \u0026amp;g_dataBuffer[g_dataBufferIndex]; /* å¡«å……æ•°æ®è®°å½• */ record-\u0026gt;timestamp = RTC_GetTimestamp(); record-\u0026gt;temperature = sensorData-\u0026gt;temperature; record-\u0026gt;pressure = sensorData-\u0026gt;pressure; record-\u0026gt;flow_rate = sensorData-\u0026gt;flow_rate; record-\u0026gt;vibration = sensorData-\u0026gt;vibration; record-\u0026gt;system_status = g_systemStatus.error_code; /* æ›´æ–°ç¼“å†²åŒºç´¢å¼• */ g_dataBufferIndex = (g_dataBufferIndex + 1) % DATA_BUFFER_SIZE; g_totalRecords++; /* æ£€æŸ¥æ˜¯å¦éœ€è¦ä¿å­˜åˆ°Flash */ if (g_dataBufferIndex % 100 == 0) { DataLogger_SaveToFlash(); } } /** * @brief æ•°æ®æ»¤æ³¢å¤„ç† */ void DataLogger_FilterSensorData(SensorData_t* sensorData) { static SensorData_t filterBuffer[5]; static uint8_t filterIndex = 0; /* æ›´æ–°æ»¤æ³¢ç¼“å†²åŒº */ filterBuffer[filterIndex] = *sensorData; filterIndex = (filterIndex + 1) % 5; /* è®¡ç®—ç§»åŠ¨å¹³å‡å€¼ */ float tempSum = 0.0, pressureSum = 0.0; float flowSum = 0.0, vibrationSum = 0.0; for (int i = 0; i \u0026lt; 5; i++) { tempSum += filterBuffer[i].temperature; pressureSum += filterBuffer[i].pressure; flowSum += filterBuffer[i].flow_rate; vibrationSum += filterBuffer[i].vibration; } sensorData-\u0026gt;temperature = tempSum / 5.0; sensorData-\u0026gt;pressure = pressureSum / 5.0; sensorData-\u0026gt;flow_rate = flowSum / 5.0; sensorData-\u0026gt;vibration = vibrationSum / 5.0; } /** * @brief æ•°æ®æœ‰æ•ˆæ€§æ£€æŸ¥ */ bool DataLogger_ValidateSensorData(SensorData_t* sensorData) { bool isValid = true; /* æ¸©åº¦èŒƒå›´æ£€æŸ¥ */ if (sensorData-\u0026gt;temperature \u0026lt; -40.0 || sensorData-\u0026gt;temperature \u0026gt; 125.0) { sensorData-\u0026gt;temperature = 25.0; // é»˜è®¤å€¼ isValid = false; } /* å‹åŠ›èŒƒå›´æ£€æŸ¥ */ if (sensorData-\u0026gt;pressure \u0026lt; 0.0 || sensorData-\u0026gt;pressure \u0026gt; 20.0) { sensorData-\u0026gt;pressure = 0.0; isValid = false; } /* æµé‡èŒƒå›´æ£€æŸ¥ */ if (sensorData-\u0026gt;flow_rate \u0026lt; 0.0 || sensorData-\u0026gt;flow_rate \u0026gt; 1000.0) { sensorData-\u0026gt;flow_rate = 0.0; isValid = false; } /* æŒ¯åŠ¨èŒƒå›´æ£€æŸ¥ */ if (sensorData-\u0026gt;vibration \u0026lt; 0.0 || sensorData-\u0026gt;vibration \u0026gt; 50.0) { sensorData-\u0026gt;vibration = 0.0; isValid = false; } return isValid; } ğŸ”§ ç³»ç»Ÿæµ‹è¯•ä¸éªŒè¯ åŠŸèƒ½æµ‹è¯•æ¸…å• ç¡¬ä»¶æµ‹è¯•: âœ“ ç”µæºè¾“å…¥æµ‹è¯• (24V DC Â±10%) âœ“ å·¥ä½œæ¸©åº¦æµ‹è¯• (-20Â°C ~ +70Â°C) âœ“ EMIæŠ—å¹²æ‰°æµ‹è¯• (IEC 61000-4-3) âœ“ é˜²æŠ¤ç­‰çº§æµ‹è¯• (IP65) âœ“ æŒ¯åŠ¨æµ‹è¯• (IEC 60068-2-6) è½¯ä»¶æµ‹è¯•: âœ“ ä¼ æ„Ÿå™¨ç²¾åº¦æµ‹è¯• (Â±0.1%) âœ“ Modbusé€šä¿¡æµ‹è¯• (RTU/TCP) âœ“ æ•°æ®è®°å½•æµ‹è¯• (1000æ¡/ç§’) âœ“ çœ‹é—¨ç‹—åŠŸèƒ½æµ‹è¯• âœ“ æ•…éšœæ¢å¤æµ‹è¯• æ€§èƒ½æŒ‡æ ‡: âœ“ å¯åŠ¨æ—¶é—´: \u0026lt; 2ç§’ âœ“ æ•°æ®æ›´æ–°é¢‘ç‡: 10Hz âœ“ é€šä¿¡å“åº”æ—¶é—´: \u0026lt; 100ms âœ“ å­˜å‚¨å®¹é‡: 10,000æ¡è®°å½• âœ“ åŠŸè€—: \u0026lt; 5W ç°åœºæµ‹è¯•ç»“æœ æµ‹è¯•ç¯å¢ƒ: å·¥ä¸šæ³µç«™ç°åœº æµ‹è¯•æ—¶é—´: 72å°æ—¶è¿ç»­è¿è¡Œ ä¼ æ„Ÿå™¨æµ‹è¯•ç»“æœ: - æ¸©åº¦æµ‹é‡ç²¾åº¦: Â±0.05Â°C (PT100, 0-100Â°CèŒƒå›´) - å‹åŠ›æµ‹é‡ç²¾åº¦: Â±0.2%FS (4-20mA, 0-10Bar) - æµé‡æµ‹é‡ç²¾åº¦: Â±1.0% (è„‰å†²è¾“å‡º, 0-500L/min) - æŒ¯åŠ¨æµ‹é‡ç²¾åº¦: Â±5% (IEPE, 0-10g) é€šä¿¡æµ‹è¯•ç»“æœ: - Modbus RTU: 9600bps, 0é”™è¯¯ - Modbus TCP: 100Mbps, \u0026lt;10mså»¶è¿Ÿ - æ•°æ®å®Œæ•´æ€§: 99.99% - è¿æ¥ç¨³å®šæ€§: 72å°æ—¶æ— æ–­çº¿ ç³»ç»Ÿç¨³å®šæ€§: - è¿ç»­è¿è¡Œæ—¶é—´: 72å°æ—¶ - å†…å­˜ä½¿ç”¨ç‡: 45% - CPUä½¿ç”¨ç‡: 30% - å­˜å‚¨ç©ºé—´ä½¿ç”¨: 23% ğŸ“ˆ é¡¹ç›®åº”ç”¨åœºæ™¯ å·¥ä¸šåº”ç”¨æ¡ˆä¾‹ æ³µç«™ç›‘æ§ç³»ç»Ÿ\n","keywords":["STM32","Cè¯­è¨€","Modbus","ä¼ æ„Ÿå™¨","åµŒå…¥å¼æ§åˆ¶"],"articleBody":"ğŸ”§ é¡¹ç›®æ¦‚è¿° è¿™æ˜¯ä¸€ä¸ªåŸºäºSTM32F4ç³»åˆ—å¾®æ§åˆ¶å™¨çš„æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒï¼Œä¸“é—¨ç”¨äºå·¥ä¸šç°åœºçš„æ•°æ®é‡‡é›†ã€è®¾å¤‡æ§åˆ¶å’Œæ•°æ®é€šä¿¡ã€‚è¯¥æ§åˆ¶å•å…ƒé›†æˆäº†å¤šç§å·¥ä¸šä¼ æ„Ÿå™¨ï¼Œæ”¯æŒModbus RTU/TCPé€šä¿¡åè®®ï¼Œå¯ä½œä¸ºPLCç³»ç»Ÿçš„è¡¥å……æ§åˆ¶å™¨æˆ–ç‹¬ç«‹çš„ç›‘æ§èŠ‚ç‚¹ä½¿ç”¨ã€‚\nğŸ¯ é¡¹ç›®ç›®æ ‡ å®ç°å¤šä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†å’Œé¢„å¤„ç† æä¾›æœ¬åœ°æ§åˆ¶å’Œä¿æŠ¤åŠŸèƒ½ æ”¯æŒModbuså·¥ä¸šé€šä¿¡åè®® å…·å¤‡æ•°æ®è®°å½•å’Œæ•…éšœè¯Šæ–­èƒ½åŠ› æ»¡è¶³å·¥ä¸šç¯å¢ƒçš„å¯é æ€§è¦æ±‚ ğŸ”§ ç¡¬ä»¶æ¶æ„ STM32æ§åˆ¶æ¿è®¾è®¡ ç¡¬ä»¶é…ç½®: ä¸»æ§åˆ¶å™¨: â”œâ”€â”€ STM32F407VGT6 (ARM Cortex-M4, 168MHz) â”œâ”€â”€ 1MB Flash, 192KB RAM â”œâ”€â”€ 3Ã—UART (é€šä¿¡æ¥å£) â”œâ”€â”€ 2Ã—I2C (ä¼ æ„Ÿå™¨æ‰©å±•) â”œâ”€â”€ 3Ã—SPI (é«˜é€Ÿæ•°æ®æ¥å£) â”œâ”€â”€ 16Ã—12ä½ADC (æ¨¡æ‹Ÿé‡é‡‡é›†) â””â”€â”€ 2Ã—12ä½DAC (æ¨¡æ‹Ÿé‡è¾“å‡º) ç”µæºç®¡ç†: â”œâ”€â”€ 24V DCå·¥ä¸šç”µæºè¾“å…¥ â”œâ”€â”€ 5V/3.3V DC-DCè½¬æ¢å™¨ â”œâ”€â”€ ç”µæºæ»¤æ³¢å’Œä¿æŠ¤ç”µè·¯ â”œâ”€â”€ å¤‡ç”¨ç”µæ±  (RTCå’Œæ•°æ®ä¿æŒ) â””â”€â”€ çœ‹é—¨ç‹—å®šæ—¶å™¨ é€šä¿¡æ¥å£: â”œâ”€â”€ RS485æ¥å£ (Modbus RTU) â”œâ”€â”€ Ethernetæ¥å£ (Modbus TCP) â”œâ”€â”€ USBæ¥å£ (è°ƒè¯•å’Œé…ç½®) â”œâ”€â”€ CANæ€»çº¿æ¥å£ (è®¾å¤‡äº’è”) â””â”€â”€ WiFiæ¨¡å— (å¯é€‰æ— çº¿é€šä¿¡) ä¼ æ„Ÿå™¨æ¥å£ç”µè·¯ ä¼ æ„Ÿå™¨è¿æ¥: â”œâ”€â”€ æ¸©åº¦ä¼ æ„Ÿå™¨ (PT100) â”‚ â”œâ”€â”€ æ’æµæºæ¿€åŠ±ç”µè·¯ â”‚ â”œâ”€â”€ ä¿¡å·æ”¾å¤§å’Œæ»¤æ³¢ â”‚ â””â”€â”€ å†·ç«¯è¡¥å¿ â”œâ”€â”€ å‹åŠ›ä¼ æ„Ÿå™¨ (4-20mA) â”‚ â”œâ”€â”€ ç²¾å¯†ç”µé˜»é‡‡æ · â”‚ â”œâ”€â”€ è¿‡å‹ä¿æŠ¤ â”‚ â””â”€â”€ ä¿¡å·éš”ç¦» â”œâ”€â”€ æµé‡è®¡ (è„‰å†²è¾“å‡º) â”‚ â”œâ”€â”€ å…‰ç”µéš”ç¦»è¾“å…¥ â”‚ â”œâ”€â”€ é¢‘ç‡æµ‹é‡ç”µè·¯ â”‚ â””â”€â”€ æŠ—å¹²æ‰°æ»¤æ³¢ â””â”€â”€ æŒ¯åŠ¨ä¼ æ„Ÿå™¨ (IEPE) â”œâ”€â”€ æ’æµæºä¾›ç”µ â”œâ”€â”€ ACä¿¡å·æ”¾å¤§ â””â”€â”€ RMSè½¬æ¢ç”µè·¯ ğŸ’» è½¯ä»¶æ¶æ„ ä¸»ç¨‹åºæ¡†æ¶ /** * @file main.c * @brief æ™ºèƒ½æ§åˆ¶å•å…ƒä¸»ç¨‹åº * @author Automation Technician * @date 2025-11-12 */ #include \"main.h\" #include \"sensor_manager.h\" #include \"modbus_server.h\" #include \"data_logger.h\" #include \"watchdog.h\" #include \"system_config.h\" /* å…¨å±€å˜é‡å®šä¹‰ */ SystemStatus_t g_systemStatus; SensorData_t g_sensorData; ModbusRegisters_t g_modbusRegisters; uint32_t g_systemTick = 0; /* å‡½æ•°å£°æ˜ */ static void SystemClock_Config(void); static void GPIO_Init(void); static void Peripherals_Init(void); static void Task_SensorAcquisition(void); static void Task_DataProcessing(void); static void Task_Communication(void); static void Task_SystemMonitoring(void); /** * @brief ä¸»å‡½æ•° */ int main(void) { /* ç³»ç»Ÿåˆå§‹åŒ– */ HAL_Init(); SystemClock_Config(); GPIO_Init(); Peripherals_Init(); /* å¤–è®¾åˆå§‹åŒ– */ SensorManager_Init(); ModbusServer_Init(); DataLogger_Init(); Watchdog_Init(); /* ç³»ç»ŸçŠ¶æ€åˆå§‹åŒ– */ g_systemStatus.mode = MODE_AUTO; g_systemStatus.error_code = ERROR_NONE; g_systemStatus.uptime = 0; /* ä¸»å¾ªç¯ */ while (1) { g_systemTick = HAL_GetTick(); /* ä»»åŠ¡è°ƒåº¦ */ Task_SensorAcquisition(); // 100mså‘¨æœŸ Task_DataProcessing(); // 500mså‘¨æœŸ Task_Communication(); // å®æ—¶å¤„ç† Task_SystemMonitoring(); // 1000mså‘¨æœŸ /* å–‚ç‹— */ Watchdog_Refresh(); /* ä½åŠŸè€—å¤„ç† */ if (g_systemStatus.mode == MODE_SLEEP) { __WFI(); } } } /** * @brief ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†ä»»åŠ¡ */ static void Task_SensorAcquisition(void) { static uint32_t lastAcquisitionTime = 0; /* 100msé‡‡é›†å‘¨æœŸ */ if (g_systemTick - lastAcquisitionTime \u003e= 100) { /* é‡‡é›†æ¸©åº¦æ•°æ® */ g_sensorData.temperature = SensorManager_ReadTemperature(); /* é‡‡é›†å‹åŠ›æ•°æ® */ g_sensorData.pressure = SensorManager_ReadPressure(); /* é‡‡é›†æµé‡æ•°æ® */ g_sensorData.flow_rate = SensorManager_ReadFlowRate(); /* é‡‡é›†æŒ¯åŠ¨æ•°æ® */ g_sensorData.vibration = SensorManager_ReadVibration(); /* æ›´æ–°æ•°æ®æ—¶é—´æˆ³ */ g_sensorData.timestamp = g_systemTick; lastAcquisitionTime = g_systemTick; } } /** * @brief æ•°æ®å¤„ç†ä»»åŠ¡ */ static void Task_DataProcessing(void) { static uint32_t lastProcessingTime = 0; /* 500mså¤„ç†å‘¨æœŸ */ if (g_systemTick - lastProcessingTime \u003e= 500) { /* æ•°æ®æ»¤æ³¢å¤„ç† */ DataLogger_FilterSensorData(\u0026g_sensorData); /* æ•°æ®èŒƒå›´æ£€æŸ¥ */ DataLogger_ValidateSensorData(\u0026g_sensorData); /* è®¡ç®—è¡ç”Ÿå‚æ•° */ g_sensorData.pressure_rate = DataLogger_CalculatePressureRate(); g_sensorData.flow_total = DataLogger_CalculateFlowTotal(); /* æ›´æ–°Modbuså¯„å­˜å™¨ */ ModbusServer_UpdateRegisters(\u0026g_sensorData); lastProcessingTime = g_systemTick; } } /** * @brief é€šä¿¡å¤„ç†ä»»åŠ¡ */ static void Task_Communication(void) { /* Modbus RTUé€šä¿¡å¤„ç† */ if (HAL_UART_GetState(\u0026huart1) == HAL_UART_STATE_BUSY_RX) { ModbusServer_ProcessRTU(); } /* Modbus TCPé€šä¿¡å¤„ç† */ if (HAL_ETH_GetState(\u0026heth) == HAL_ETH_STATE_BUSY_RX) { ModbusServer_ProcessTCP(); } /* USBé€šä¿¡å¤„ç† (è°ƒè¯•ç”¨) */ if (HAL_UART_GetState(\u0026huart3) == HAL_UART_STATE_BUSY_RX) { ProcessUSBCommand(); } } /** * @brief ç³»ç»Ÿç›‘æ§ä»»åŠ¡ */ static void Task_SystemMonitoring(void) { static uint32_t lastMonitorTime = 0; /* 1000msç›‘æ§å‘¨æœŸ */ if (g_systemTick - lastMonitorTime \u003e= 1000) { /* æ›´æ–°ç³»ç»Ÿè¿è¡Œæ—¶é—´ */ g_systemStatus.uptime++; /* æ£€æŸ¥ç³»ç»Ÿé”™è¯¯ */ SystemError_Check(); /* ç›‘æ§ç”µæºç”µå‹ */ if (SystemMonitor_GetPowerVoltage() \u003c 20.0) { g_systemStatus.error_code |= ERROR_LOW_VOLTAGE; } /* æ£€æŸ¥å­˜å‚¨ç©ºé—´ */ if (DataLogger_GetFreeSpace() \u003c 1024) { g_systemStatus.error_code |= ERROR_STORAGE_FULL; } /* ç³»ç»ŸçŠ¶æ€LEDæŒ‡ç¤º */ SystemStatus_UpdateLED(); lastMonitorTime = g_systemTick; } } ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å— /** * @file sensor_manager.c * @brief ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å— */ #include \"sensor_manager.h\" #include \"adc.h\" #include \"tim.h\" #include \"i2c.h\" /* ä¼ æ„Ÿå™¨æ ¡å‡†å‚æ•° */ typedef struct { float offset; float scale; float filter_coefficient; } SensorCalibration_t; static SensorCalibration_t tempCalib = {0.0, 1.0, 0.1}; static SensorCalibration_t pressureCalib = {0.0, 1.0, 0.1}; /** * @brief æ¸©åº¦ä¼ æ„Ÿå™¨è¯»å– (PT100) */ float SensorManager_ReadTemperature(void) { static float filteredTemp = 25.0; uint16_t adcValue; float voltage, resistance, temperature; /* è¯»å–ADCå€¼ */ adcValue = ADC_ReadChannel(ADC_CHANNEL_TEMP); /* è½¬æ¢ä¸ºç”µå‹ */ voltage = (float)adcValue * 3.3f / 4096.0f; /* è®¡ç®—PT100ç”µé˜» */ resistance = voltage * 1000.0f / 1.0f; /* 1mAæ’æµæº */ /* PT100ç”µé˜»-æ¸©åº¦è½¬æ¢ (Callendar-Van Dusenæ–¹ç¨‹) */ if (resistance \u003e= 100.0) { temperature = -242.02 + 2.2228 * resistance + 0.00258 * resistance * resistance; } else { temperature = -242.02 + 2.2228 * resistance; } /* åº”ç”¨æ ¡å‡†å‚æ•° */ temperature = temperature * tempCalib.scale + tempCalib.offset; /* è½¯ä»¶æ»¤æ³¢ */ filteredTemp = filteredTemp * (1.0 - tempCalib.filter_coefficient) + temperature * tempCalib.filter_coefficient; return filteredTemp; } /** * @brief å‹åŠ›ä¼ æ„Ÿå™¨è¯»å– (4-20mA) */ float SensorManager_ReadPressure(void) { static float filteredPressure = 0.0; uint16_t adcValue; float current, pressure; /* è¯»å–ADCå€¼ */ adcValue = ADC_ReadChannel(ADC_CHANNEL_PRESSURE); /* è½¬æ¢ä¸ºç”µæµ (4-20mAå¯¹åº”0.8-4Vç”µå‹) */ float voltage = (float)adcValue * 3.3f / 4096.0f; current = (voltage - 0.8f) * 5.0f; /* 4-20mA */ /* è½¬æ¢ä¸ºå‹åŠ›å€¼ (0-10Bar) */ pressure = (current - 4.0f) * 10.0f / 16.0f; /* 4-20mA -\u003e 0-10Bar */ /* è´Ÿå€¼å¤„ç† */ if (pressure \u003c 0.0) pressure = 0.0; /* åº”ç”¨æ ¡å‡†å‚æ•° */ pressure = pressure * pressureCalib.scale + pressureCalib.offset; /* è½¯ä»¶æ»¤æ³¢ */ filteredPressure = filteredPressure * (1.0 - pressureCalib.filter_coefficient) + pressure * pressureCalib.filter_coefficient; return filteredPressure; } /** * @brief æµé‡ä¼ æ„Ÿå™¨è¯»å– (è„‰å†²è¾“å‡º) */ float SensorManager_ReadFlowRate(void) { static uint32_t lastPulseCount = 0; static uint32_t lastReadTime = 0; static float flowRate = 0.0; uint32_t currentPulseCount, pulseDelta; uint32_t timeDelta; float frequency; /* è·å–å½“å‰è„‰å†²è®¡æ•° */ currentPulseCount = TIM_GetPulseCount(TIM_FLOW); /* è®¡ç®—æ—¶é—´å·® */ timeDelta = g_systemTick - lastReadTime; if (timeDelta \u003e 0) { /* è®¡ç®—è„‰å†²å¢é‡ */ pulseDelta = currentPulseCount - lastPulseCount; /* è®¡ç®—é¢‘ç‡ (Hz) */ frequency = (float)pulseDelta * 1000.0f / (float)timeDelta; /* è½¬æ¢ä¸ºæµé‡ (L/min) */ flowRate = frequency * 60.0f / 100.0f; /* 100è„‰å†²/L */ /* æ›´æ–°å†å²è®°å½• */ lastPulseCount = currentPulseCount; lastReadTime = g_systemTick; } return flowRate; } /** * @brief æŒ¯åŠ¨ä¼ æ„Ÿå™¨è¯»å– (IEPE) */ float SensorManager_ReadVibration(void) { uint16_t adcValue; float voltage, rmsValue; /* è¯»å–ADCå€¼ */ adcValue = ADC_ReadChannel(ADC_CHANNEL_VIBRATION); /* è½¬æ¢ä¸ºç”µå‹ */ voltage = (float)adcValue * 3.3f / 4096.0f; /* è®¡ç®—RMSå€¼ */ rmsValue = Vibration_CalculateRMS(voltage); /* è½¬æ¢ä¸ºåŠ é€Ÿåº¦å€¼ (g) */ float acceleration = rmsValue * 10.0f; /* 10g/Vçµæ•åº¦ */ return acceleration; } Modbusé€šä¿¡æ¨¡å— /** * @file modbus_server.c * @brief ModbusæœåŠ¡å™¨å®ç° */ #include \"modbus_server.h\" #include \"usart.h\" #include \"ethernet.h\" /* Modbuså¯„å­˜å™¨æ˜ å°„ */ typedef union { struct { uint16_t holding_registers[100]; uint16_t input_registers[100]; uint16_t coils[100]; uint16_t discrete_inputs[100]; } registers; uint16_t raw[400]; } ModbusMemoryMap_t; static ModbusMemoryMap_t g_modbusMemory; /** * @brief Modbuså¯„å­˜å™¨æ˜ å°„ */ void ModbusServer_UpdateRegisters(SensorData_t* sensorData) { /* è¾“å…¥å¯„å­˜å™¨ (åªè¯») */ g_modbusMemory.registers.input_registers[0] = (uint16_t)(sensorData-\u003etemperature * 10.0); // æ¸©åº¦ (0.1Â°C) g_modbusMemory.registers.input_registers[1] = (uint16_t)(sensorData-\u003epressure * 100.0); // å‹åŠ› (0.01Bar) g_modbusMemory.registers.input_registers[2] = (uint16_t)(sensorData-\u003eflow_rate * 10.0); // æµé‡ (0.1L/min) g_modbusMemory.registers.input_registers[3] = (uint16_t)(sensorData-\u003evibration * 100.0); // æŒ¯åŠ¨ (0.01g) /* ä¿æŒå¯„å­˜å™¨ (è¯»å†™) */ g_modbusMemory.registers.holding_registers[0] = (uint16_t)(g_systemStatus.mode); // è¿è¡Œæ¨¡å¼ g_modbusMemory.registers.holding_registers[1] = (uint16_t)(g_systemStatus.error_code); // é”™è¯¯ä»£ç  g_modbusMemory.registers.holding_registers[2] = (uint16_t)(g_systemStatus.uptime); // è¿è¡Œæ—¶é—´ } /** * @brief å¤„ç†Modbus RTUè¯·æ±‚ */ void ModbusServer_ProcessRTU(void) { static uint8_t rxBuffer[256]; static uint8_t txBuffer[256]; uint16_t rxLength, txLength; /* æ¥æ”¶æ•°æ® */ if (UART_ReceiveBuffer(\u0026huart1, rxBuffer, \u0026rxLength)) { /* è§£æModbusè¯·æ±‚ */ ModbusRequest_t request; if (Modbus_ParseRequest(rxBuffer, rxLength, \u0026request)) { /* å¤„ç†è¯·æ±‚ */ ModbusResponse_t response; Modbus_ProcessRequest(\u0026request, \u0026response); /* ç”Ÿæˆå“åº”å¸§ */ txLength = Modbus_GenerateResponse(\u0026response, txBuffer); /* å‘é€å“åº” */ UART_Transmit(\u0026huart1, txBuffer, txLength); } } } /** * @brief å¤„ç†Modbus TCPè¯·æ±‚ */ void ModbusServer_ProcessTCP(void) { /* TCPé€šä¿¡å¤„ç† (ç®€åŒ–å®ç°) */ uint8_t tcpBuffer[512]; uint16_t tcpLength; if (Ethernet_ReceiveData(tcpBuffer, \u0026tcpLength)) { /* è§£æMBAPå¤´éƒ¨å’ŒModbus PDU */ ModbusTCP_Request_t tcpRequest; if (ModbusTCP_ParseRequest(tcpBuffer, tcpLength, \u0026tcpRequest)) { /* å¤„ç†Modbusè¯·æ±‚ */ ModbusResponse_t response; Modbus_ProcessRequest(\u0026tcpRequest.modbus_request, \u0026response); /* ç”ŸæˆTCPå“åº” */ uint16_t responseLength; responseLength = ModbusTCP_GenerateResponse( \u0026tcpRequest, \u0026response, tcpBuffer); /* å‘é€TCPå“åº” */ Ethernet_TransmitData(tcpBuffer, responseLength); } } } /** * @brief å¤„ç†ModbusåŠŸèƒ½ç  */ void Modbus_ProcessRequest(ModbusRequest_t* request, ModbusResponse_t* response) { response-\u003eslave_address = request-\u003eslave_address; response-\u003efunction_code = request-\u003efunction_code; switch (request-\u003efunction_code) { case MODBUS_FC_READ_HOLDING_REGISTERS: Modbus_ReadHoldingRegisters(request, response); break; case MODBUS_FC_READ_INPUT_REGISTERS: Modbus_ReadInputRegisters(request, response); break; case MODBUS_FC_WRITE_SINGLE_REGISTER: Modbus_WriteSingleRegister(request, response); break; case MODBUS_FC_WRITE_MULTIPLE_REGISTERS: Modbus_WriteMultipleRegisters(request, response); break; default: response-\u003efunction_code |= 0x80; // å¼‚å¸¸å“åº” response-\u003edata[0] = MODBUS_EXCEPTION_ILLEGAL_FUNCTION; response-\u003edata_length = 1; break; } } ğŸ“Š æ•°æ®è®°å½•ä¸åˆ†æ æ•°æ®è®°å½•åŠŸèƒ½ /** * @file data_logger.c * @brief æ•°æ®è®°å½•æ¨¡å— */ #include \"data_logger.h\" #include \"flash.h\" #include \"rtc.h\" /* æ•°æ®è®°å½•ç»“æ„ */ typedef struct { uint32_t timestamp; float temperature; float pressure; float flow_rate; float vibration; uint16_t system_status; } DataRecord_t; /* å†å²æ•°æ®ç¼“å†²åŒº */ #define DATA_BUFFER_SIZE 1000 static DataRecord_t g_dataBuffer[DATA_BUFFER_SIZE]; static uint16_t g_dataBufferIndex = 0; static uint32_t g_totalRecords = 0; /** * @brief è®°å½•ä¼ æ„Ÿå™¨æ•°æ® */ void DataLogger_RecordData(SensorData_t* sensorData) { DataRecord_t* record = \u0026g_dataBuffer[g_dataBufferIndex]; /* å¡«å……æ•°æ®è®°å½• */ record-\u003etimestamp = RTC_GetTimestamp(); record-\u003etemperature = sensorData-\u003etemperature; record-\u003epressure = sensorData-\u003epressure; record-\u003eflow_rate = sensorData-\u003eflow_rate; record-\u003evibration = sensorData-\u003evibration; record-\u003esystem_status = g_systemStatus.error_code; /* æ›´æ–°ç¼“å†²åŒºç´¢å¼• */ g_dataBufferIndex = (g_dataBufferIndex + 1) % DATA_BUFFER_SIZE; g_totalRecords++; /* æ£€æŸ¥æ˜¯å¦éœ€è¦ä¿å­˜åˆ°Flash */ if (g_dataBufferIndex % 100 == 0) { DataLogger_SaveToFlash(); } } /** * @brief æ•°æ®æ»¤æ³¢å¤„ç† */ void DataLogger_FilterSensorData(SensorData_t* sensorData) { static SensorData_t filterBuffer[5]; static uint8_t filterIndex = 0; /* æ›´æ–°æ»¤æ³¢ç¼“å†²åŒº */ filterBuffer[filterIndex] = *sensorData; filterIndex = (filterIndex + 1) % 5; /* è®¡ç®—ç§»åŠ¨å¹³å‡å€¼ */ float tempSum = 0.0, pressureSum = 0.0; float flowSum = 0.0, vibrationSum = 0.0; for (int i = 0; i \u003c 5; i++) { tempSum += filterBuffer[i].temperature; pressureSum += filterBuffer[i].pressure; flowSum += filterBuffer[i].flow_rate; vibrationSum += filterBuffer[i].vibration; } sensorData-\u003etemperature = tempSum / 5.0; sensorData-\u003epressure = pressureSum / 5.0; sensorData-\u003eflow_rate = flowSum / 5.0; sensorData-\u003evibration = vibrationSum / 5.0; } /** * @brief æ•°æ®æœ‰æ•ˆæ€§æ£€æŸ¥ */ bool DataLogger_ValidateSensorData(SensorData_t* sensorData) { bool isValid = true; /* æ¸©åº¦èŒƒå›´æ£€æŸ¥ */ if (sensorData-\u003etemperature \u003c -40.0 || sensorData-\u003etemperature \u003e 125.0) { sensorData-\u003etemperature = 25.0; // é»˜è®¤å€¼ isValid = false; } /* å‹åŠ›èŒƒå›´æ£€æŸ¥ */ if (sensorData-\u003epressure \u003c 0.0 || sensorData-\u003epressure \u003e 20.0) { sensorData-\u003epressure = 0.0; isValid = false; } /* æµé‡èŒƒå›´æ£€æŸ¥ */ if (sensorData-\u003eflow_rate \u003c 0.0 || sensorData-\u003eflow_rate \u003e 1000.0) { sensorData-\u003eflow_rate = 0.0; isValid = false; } /* æŒ¯åŠ¨èŒƒå›´æ£€æŸ¥ */ if (sensorData-\u003evibration \u003c 0.0 || sensorData-\u003evibration \u003e 50.0) { sensorData-\u003evibration = 0.0; isValid = false; } return isValid; } ğŸ”§ ç³»ç»Ÿæµ‹è¯•ä¸éªŒè¯ åŠŸèƒ½æµ‹è¯•æ¸…å• ç¡¬ä»¶æµ‹è¯•: âœ“ ç”µæºè¾“å…¥æµ‹è¯• (24V DC Â±10%) âœ“ å·¥ä½œæ¸©åº¦æµ‹è¯• (-20Â°C ~ +70Â°C) âœ“ EMIæŠ—å¹²æ‰°æµ‹è¯• (IEC 61000-4-3) âœ“ é˜²æŠ¤ç­‰çº§æµ‹è¯• (IP65) âœ“ æŒ¯åŠ¨æµ‹è¯• (IEC 60068-2-6) è½¯ä»¶æµ‹è¯•: âœ“ ä¼ æ„Ÿå™¨ç²¾åº¦æµ‹è¯• (Â±0.1%) âœ“ Modbusé€šä¿¡æµ‹è¯• (RTU/TCP) âœ“ æ•°æ®è®°å½•æµ‹è¯• (1000æ¡/ç§’) âœ“ çœ‹é—¨ç‹—åŠŸèƒ½æµ‹è¯• âœ“ æ•…éšœæ¢å¤æµ‹è¯• æ€§èƒ½æŒ‡æ ‡: âœ“ å¯åŠ¨æ—¶é—´: \u003c 2ç§’ âœ“ æ•°æ®æ›´æ–°é¢‘ç‡: 10Hz âœ“ é€šä¿¡å“åº”æ—¶é—´: \u003c 100ms âœ“ å­˜å‚¨å®¹é‡: 10,000æ¡è®°å½• âœ“ åŠŸè€—: \u003c 5W ç°åœºæµ‹è¯•ç»“æœ æµ‹è¯•ç¯å¢ƒ: å·¥ä¸šæ³µç«™ç°åœº æµ‹è¯•æ—¶é—´: 72å°æ—¶è¿ç»­è¿è¡Œ ä¼ æ„Ÿå™¨æµ‹è¯•ç»“æœ: - æ¸©åº¦æµ‹é‡ç²¾åº¦: Â±0.05Â°C (PT100, 0-100Â°CèŒƒå›´) - å‹åŠ›æµ‹é‡ç²¾åº¦: Â±0.2%FS (4-20mA, 0-10Bar) - æµé‡æµ‹é‡ç²¾åº¦: Â±1.0% (è„‰å†²è¾“å‡º, 0-500L/min) - æŒ¯åŠ¨æµ‹é‡ç²¾åº¦: Â±5% (IEPE, 0-10g) é€šä¿¡æµ‹è¯•ç»“æœ: - Modbus RTU: 9600bps, 0é”™è¯¯ - Modbus TCP: 100Mbps, \u003c10mså»¶è¿Ÿ - æ•°æ®å®Œæ•´æ€§: 99.99% - è¿æ¥ç¨³å®šæ€§: 72å°æ—¶æ— æ–­çº¿ ç³»ç»Ÿç¨³å®šæ€§: - è¿ç»­è¿è¡Œæ—¶é—´: 72å°æ—¶ - å†…å­˜ä½¿ç”¨ç‡: 45% - CPUä½¿ç”¨ç‡: 30% - å­˜å‚¨ç©ºé—´ä½¿ç”¨: 23% ğŸ“ˆ é¡¹ç›®åº”ç”¨åœºæ™¯ å·¥ä¸šåº”ç”¨æ¡ˆä¾‹ æ³µç«™ç›‘æ§ç³»ç»Ÿ\nå‹åŠ›ã€æµé‡ã€æ¸©åº¦å®æ—¶ç›‘æ§ è®¾å¤‡çŠ¶æ€è¿œç¨‹è¯Šæ–­ èƒ½è€—åˆ†æå’Œä¼˜åŒ– ç”Ÿäº§çº¿è®¾å¤‡æ§åˆ¶\nè®¾å¤‡è¿è¡Œå‚æ•°ç›‘æ§ è´¨é‡æ•°æ®é‡‡é›† é¢„é˜²æ€§ç»´æŠ¤æ”¯æŒ ç¯å¢ƒç›‘æµ‹ç³»ç»Ÿ\næ¸©æ¹¿åº¦ã€æ°”ä½“æµ“åº¦ç›‘æµ‹ æ•°æ®è®°å½•å’ŒæŠ¥è­¦ è¿œç¨‹æ•°æ®è®¿é—® ğŸ“ æŠ€æœ¯åˆ›æ–°ç‚¹ å¤šä¼ æ„Ÿå™¨èåˆ: é›†æˆæ¸©åº¦ã€å‹åŠ›ã€æµé‡ã€æŒ¯åŠ¨ç­‰å¤šç§ä¼ æ„Ÿå™¨ å·¥ä¸šé€šä¿¡åè®®: æ”¯æŒModbus RTU/TCPæ ‡å‡†å·¥ä¸šåè®® æœ¬åœ°æ™ºèƒ½å¤„ç†: è¾¹ç¼˜è®¡ç®—èƒ½åŠ›ï¼Œå‡å°‘ä¸Šä½æœºè´Ÿè½½ é«˜å¯é æ€§è®¾è®¡: çœ‹é—¨ç‹—ã€ç”µæºç›‘æ§ã€EMCé˜²æŠ¤ çµæ´»é…ç½®: é€šè¿‡Modbuså¯„å­˜å™¨å¯åœ¨çº¿é…ç½®å‚æ•° è¯¥æ§åˆ¶å•å…ƒå·²æˆåŠŸåº”ç”¨äºå¤šä¸ªå·¥ä¸šç°åœºï¼Œä¸ºè®¾å¤‡ç›‘æ§å’Œæ•°æ®åˆ†ææä¾›äº†å¯é çš„æŠ€æœ¯æ”¯æ’‘ã€‚\né¡¹ç›®ä»£ç å·²é€šè¿‡ä¸¥æ ¼çš„ä»£ç å®¡æŸ¥å’Œæµ‹è¯•éªŒè¯ï¼Œç¬¦åˆå·¥ä¸šçº§åº”ç”¨æ ‡å‡†ã€‚\n","wordCount":"1603","inLanguage":"en","image":"https://images.unsplash.com/photo-1581091226825-a6a2a5aee158?w=800\u0026h=400\u0026fit=crop","datePublished":"2025-11-12T12:00:00+08:00","dateModified":"2025-11-12T12:00:00+08:00","author":{"@type":"Person","name":"dmk69"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://hugo-maker-blog.vercel.app/projects/embedded-control-unit/"},"publisher":{"@type":"Organization","name":"Automation \u0026 Industrial Control Technician","logo":{"@type":"ImageObject","url":"https://hugo-maker-blog.vercel.app/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://hugo-maker-blog.vercel.app/ accesskey=h title="Home (Alt + H)"><img src=https://hugo-maker-blog.vercel.app/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hugo-maker-blog.vercel.app/projects/ title=é¡¹ç›®å±•ç¤º><span>é¡¹ç›®å±•ç¤º</span></a></li><li><a href=https://hugo-maker-blog.vercel.app/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://hugo-maker-blog.vercel.app/tags/ title=æ ‡ç­¾><span>æ ‡ç­¾</span></a></li><li><a href=https://hugo-maker-blog.vercel.app/about/ title=å…³äº><span>å…³äº</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://hugo-maker-blog.vercel.app/>Home</a>&nbsp;Â»&nbsp;<a href=https://hugo-maker-blog.vercel.app/projects/>Projects</a></div><h1 class="post-title entry-hint-parent">æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒ</h1><div class=post-meta><span title='2025-11-12 12:00:00 +0800 CST'>2025-11-12</span>&nbsp;Â·&nbsp;<span>8 min</span>&nbsp;Â·&nbsp;<span>1603 words</span>&nbsp;Â·&nbsp;<span>dmk69</span></div></header><figure class=entry-cover><img loading=eager src="https://images.unsplash.com/photo-1581091226825-a6a2a5aee158?w=800&amp;h=400&amp;fit=crop" alt=æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒ><figcaption>åŸºäºSTM32çš„å·¥ä¸šæ§åˆ¶å•å…ƒ - ä¼ æ„Ÿå™¨é›†æˆä¸Modbusé€šä¿¡</figcaption></figure><div class=post-content><h2 id=-é¡¹ç›®æ¦‚è¿°>ğŸ”§ é¡¹ç›®æ¦‚è¿°<a hidden class=anchor aria-hidden=true href=#-é¡¹ç›®æ¦‚è¿°>#</a></h2><p>è¿™æ˜¯ä¸€ä¸ªåŸºäºSTM32F4ç³»åˆ—å¾®æ§åˆ¶å™¨çš„æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒï¼Œä¸“é—¨ç”¨äºå·¥ä¸šç°åœºçš„æ•°æ®é‡‡é›†ã€è®¾å¤‡æ§åˆ¶å’Œæ•°æ®é€šä¿¡ã€‚è¯¥æ§åˆ¶å•å…ƒé›†æˆäº†å¤šç§å·¥ä¸šä¼ æ„Ÿå™¨ï¼Œæ”¯æŒModbus RTU/TCPé€šä¿¡åè®®ï¼Œå¯ä½œä¸ºPLCç³»ç»Ÿçš„è¡¥å……æ§åˆ¶å™¨æˆ–ç‹¬ç«‹çš„ç›‘æ§èŠ‚ç‚¹ä½¿ç”¨ã€‚</p><h2 id=-é¡¹ç›®ç›®æ ‡>ğŸ¯ é¡¹ç›®ç›®æ ‡<a hidden class=anchor aria-hidden=true href=#-é¡¹ç›®ç›®æ ‡>#</a></h2><ul><li>å®ç°å¤šä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†å’Œé¢„å¤„ç†</li><li>æä¾›æœ¬åœ°æ§åˆ¶å’Œä¿æŠ¤åŠŸèƒ½</li><li>æ”¯æŒModbuså·¥ä¸šé€šä¿¡åè®®</li><li>å…·å¤‡æ•°æ®è®°å½•å’Œæ•…éšœè¯Šæ–­èƒ½åŠ›</li><li>æ»¡è¶³å·¥ä¸šç¯å¢ƒçš„å¯é æ€§è¦æ±‚</li></ul><h2 id=-ç¡¬ä»¶æ¶æ„>ğŸ”§ ç¡¬ä»¶æ¶æ„<a hidden class=anchor aria-hidden=true href=#-ç¡¬ä»¶æ¶æ„>#</a></h2><h3 id=stm32æ§åˆ¶æ¿è®¾è®¡>STM32æ§åˆ¶æ¿è®¾è®¡<a hidden class=anchor aria-hidden=true href=#stm32æ§åˆ¶æ¿è®¾è®¡>#</a></h3><pre tabindex=0><code>ç¡¬ä»¶é…ç½®:
ä¸»æ§åˆ¶å™¨:
â”œâ”€â”€ STM32F407VGT6 (ARM Cortex-M4, 168MHz)
â”œâ”€â”€ 1MB Flash, 192KB RAM
â”œâ”€â”€ 3Ã—UART (é€šä¿¡æ¥å£)
â”œâ”€â”€ 2Ã—I2C (ä¼ æ„Ÿå™¨æ‰©å±•)
â”œâ”€â”€ 3Ã—SPI (é«˜é€Ÿæ•°æ®æ¥å£)
â”œâ”€â”€ 16Ã—12ä½ADC (æ¨¡æ‹Ÿé‡é‡‡é›†)
â””â”€â”€ 2Ã—12ä½DAC (æ¨¡æ‹Ÿé‡è¾“å‡º)

ç”µæºç®¡ç†:
â”œâ”€â”€ 24V DCå·¥ä¸šç”µæºè¾“å…¥
â”œâ”€â”€ 5V/3.3V DC-DCè½¬æ¢å™¨
â”œâ”€â”€ ç”µæºæ»¤æ³¢å’Œä¿æŠ¤ç”µè·¯
â”œâ”€â”€ å¤‡ç”¨ç”µæ±  (RTCå’Œæ•°æ®ä¿æŒ)
â””â”€â”€ çœ‹é—¨ç‹—å®šæ—¶å™¨

é€šä¿¡æ¥å£:
â”œâ”€â”€ RS485æ¥å£ (Modbus RTU)
â”œâ”€â”€ Ethernetæ¥å£ (Modbus TCP)
â”œâ”€â”€ USBæ¥å£ (è°ƒè¯•å’Œé…ç½®)
â”œâ”€â”€ CANæ€»çº¿æ¥å£ (è®¾å¤‡äº’è”)
â””â”€â”€ WiFiæ¨¡å— (å¯é€‰æ— çº¿é€šä¿¡)
</code></pre><h3 id=ä¼ æ„Ÿå™¨æ¥å£ç”µè·¯>ä¼ æ„Ÿå™¨æ¥å£ç”µè·¯<a hidden class=anchor aria-hidden=true href=#ä¼ æ„Ÿå™¨æ¥å£ç”µè·¯>#</a></h3><pre tabindex=0><code>ä¼ æ„Ÿå™¨è¿æ¥:
â”œâ”€â”€ æ¸©åº¦ä¼ æ„Ÿå™¨ (PT100)
â”‚   â”œâ”€â”€ æ’æµæºæ¿€åŠ±ç”µè·¯
â”‚   â”œâ”€â”€ ä¿¡å·æ”¾å¤§å’Œæ»¤æ³¢
â”‚   â””â”€â”€ å†·ç«¯è¡¥å¿
â”œâ”€â”€ å‹åŠ›ä¼ æ„Ÿå™¨ (4-20mA)
â”‚   â”œâ”€â”€ ç²¾å¯†ç”µé˜»é‡‡æ ·
â”‚   â”œâ”€â”€ è¿‡å‹ä¿æŠ¤
â”‚   â””â”€â”€ ä¿¡å·éš”ç¦»
â”œâ”€â”€ æµé‡è®¡ (è„‰å†²è¾“å‡º)
â”‚   â”œâ”€â”€ å…‰ç”µéš”ç¦»è¾“å…¥
â”‚   â”œâ”€â”€ é¢‘ç‡æµ‹é‡ç”µè·¯
â”‚   â””â”€â”€ æŠ—å¹²æ‰°æ»¤æ³¢
â””â”€â”€ æŒ¯åŠ¨ä¼ æ„Ÿå™¨ (IEPE)
    â”œâ”€â”€ æ’æµæºä¾›ç”µ
    â”œâ”€â”€ ACä¿¡å·æ”¾å¤§
    â””â”€â”€ RMSè½¬æ¢ç”µè·¯
</code></pre><h2 id=-è½¯ä»¶æ¶æ„>ğŸ’» è½¯ä»¶æ¶æ„<a hidden class=anchor aria-hidden=true href=#-è½¯ä»¶æ¶æ„>#</a></h2><h3 id=ä¸»ç¨‹åºæ¡†æ¶>ä¸»ç¨‹åºæ¡†æ¶<a hidden class=anchor aria-hidden=true href=#ä¸»ç¨‹åºæ¡†æ¶>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @file main.c
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief æ™ºèƒ½æ§åˆ¶å•å…ƒä¸»ç¨‹åº
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @author Automation Technician
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @date 2025-11-12
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;main.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;sensor_manager.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;modbus_server.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;data_logger.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;watchdog.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;system_config.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* å…¨å±€å˜é‡å®šä¹‰ */</span>
</span></span><span style=display:flex><span>SystemStatus_t g_systemStatus;
</span></span><span style=display:flex><span>SensorData_t g_sensorData;
</span></span><span style=display:flex><span>ModbusRegisters_t g_modbusRegisters;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint32_t</span> g_systemTick <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* å‡½æ•°å£°æ˜ */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>SystemClock_Config</span>(<span style=color:#66d9ef>void</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>GPIO_Init</span>(<span style=color:#66d9ef>void</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Peripherals_Init</span>(<span style=color:#66d9ef>void</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Task_SensorAcquisition</span>(<span style=color:#66d9ef>void</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Task_DataProcessing</span>(<span style=color:#66d9ef>void</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Task_Communication</span>(<span style=color:#66d9ef>void</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Task_SystemMonitoring</span>(<span style=color:#66d9ef>void</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief ä¸»å‡½æ•°
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* ç³»ç»Ÿåˆå§‹åŒ– */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>HAL_Init</span>();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>SystemClock_Config</span>();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>GPIO_Init</span>();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Peripherals_Init</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* å¤–è®¾åˆå§‹åŒ– */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>SensorManager_Init</span>();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ModbusServer_Init</span>();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DataLogger_Init</span>();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Watchdog_Init</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* ç³»ç»ŸçŠ¶æ€åˆå§‹åŒ– */</span>
</span></span><span style=display:flex><span>    g_systemStatus.mode <span style=color:#f92672>=</span> MODE_AUTO;
</span></span><span style=display:flex><span>    g_systemStatus.error_code <span style=color:#f92672>=</span> ERROR_NONE;
</span></span><span style=display:flex><span>    g_systemStatus.uptime <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* ä¸»å¾ªç¯ */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        g_systemTick <span style=color:#f92672>=</span> <span style=color:#a6e22e>HAL_GetTick</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* ä»»åŠ¡è°ƒåº¦ */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Task_SensorAcquisition</span>();    <span style=color:#75715e>// 100mså‘¨æœŸ
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>Task_DataProcessing</span>();       <span style=color:#75715e>// 500mså‘¨æœŸ
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>Task_Communication</span>();        <span style=color:#75715e>// å®æ—¶å¤„ç†
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>Task_SystemMonitoring</span>();     <span style=color:#75715e>// 1000mså‘¨æœŸ
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* å–‚ç‹— */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Watchdog_Refresh</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* ä½åŠŸè€—å¤„ç† */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (g_systemStatus.mode <span style=color:#f92672>==</span> MODE_SLEEP) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>__WFI</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†ä»»åŠ¡
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Task_SensorAcquisition</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>uint32_t</span> lastAcquisitionTime <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 100msé‡‡é›†å‘¨æœŸ */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (g_systemTick <span style=color:#f92672>-</span> lastAcquisitionTime <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>100</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* é‡‡é›†æ¸©åº¦æ•°æ® */</span>
</span></span><span style=display:flex><span>        g_sensorData.temperature <span style=color:#f92672>=</span> <span style=color:#a6e22e>SensorManager_ReadTemperature</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* é‡‡é›†å‹åŠ›æ•°æ® */</span>
</span></span><span style=display:flex><span>        g_sensorData.pressure <span style=color:#f92672>=</span> <span style=color:#a6e22e>SensorManager_ReadPressure</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* é‡‡é›†æµé‡æ•°æ® */</span>
</span></span><span style=display:flex><span>        g_sensorData.flow_rate <span style=color:#f92672>=</span> <span style=color:#a6e22e>SensorManager_ReadFlowRate</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* é‡‡é›†æŒ¯åŠ¨æ•°æ® */</span>
</span></span><span style=display:flex><span>        g_sensorData.vibration <span style=color:#f92672>=</span> <span style=color:#a6e22e>SensorManager_ReadVibration</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* æ›´æ–°æ•°æ®æ—¶é—´æˆ³ */</span>
</span></span><span style=display:flex><span>        g_sensorData.timestamp <span style=color:#f92672>=</span> g_systemTick;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        lastAcquisitionTime <span style=color:#f92672>=</span> g_systemTick;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief æ•°æ®å¤„ç†ä»»åŠ¡
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Task_DataProcessing</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>uint32_t</span> lastProcessingTime <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 500mså¤„ç†å‘¨æœŸ */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (g_systemTick <span style=color:#f92672>-</span> lastProcessingTime <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>500</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* æ•°æ®æ»¤æ³¢å¤„ç† */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DataLogger_FilterSensorData</span>(<span style=color:#f92672>&amp;</span>g_sensorData);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* æ•°æ®èŒƒå›´æ£€æŸ¥ */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DataLogger_ValidateSensorData</span>(<span style=color:#f92672>&amp;</span>g_sensorData);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* è®¡ç®—è¡ç”Ÿå‚æ•° */</span>
</span></span><span style=display:flex><span>        g_sensorData.pressure_rate <span style=color:#f92672>=</span> <span style=color:#a6e22e>DataLogger_CalculatePressureRate</span>();
</span></span><span style=display:flex><span>        g_sensorData.flow_total <span style=color:#f92672>=</span> <span style=color:#a6e22e>DataLogger_CalculateFlowTotal</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* æ›´æ–°Modbuså¯„å­˜å™¨ */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ModbusServer_UpdateRegisters</span>(<span style=color:#f92672>&amp;</span>g_sensorData);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        lastProcessingTime <span style=color:#f92672>=</span> g_systemTick;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief é€šä¿¡å¤„ç†ä»»åŠ¡
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Task_Communication</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Modbus RTUé€šä¿¡å¤„ç† */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>HAL_UART_GetState</span>(<span style=color:#f92672>&amp;</span>huart1) <span style=color:#f92672>==</span> HAL_UART_STATE_BUSY_RX) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ModbusServer_ProcessRTU</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Modbus TCPé€šä¿¡å¤„ç† */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>HAL_ETH_GetState</span>(<span style=color:#f92672>&amp;</span>heth) <span style=color:#f92672>==</span> HAL_ETH_STATE_BUSY_RX) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ModbusServer_ProcessTCP</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* USBé€šä¿¡å¤„ç† (è°ƒè¯•ç”¨) */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>HAL_UART_GetState</span>(<span style=color:#f92672>&amp;</span>huart3) <span style=color:#f92672>==</span> HAL_UART_STATE_BUSY_RX) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ProcessUSBCommand</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief ç³»ç»Ÿç›‘æ§ä»»åŠ¡
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Task_SystemMonitoring</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>uint32_t</span> lastMonitorTime <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 1000msç›‘æ§å‘¨æœŸ */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (g_systemTick <span style=color:#f92672>-</span> lastMonitorTime <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>1000</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* æ›´æ–°ç³»ç»Ÿè¿è¡Œæ—¶é—´ */</span>
</span></span><span style=display:flex><span>        g_systemStatus.uptime<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* æ£€æŸ¥ç³»ç»Ÿé”™è¯¯ */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>SystemError_Check</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* ç›‘æ§ç”µæºç”µå‹ */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>SystemMonitor_GetPowerVoltage</span>() <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>20.0</span>) {
</span></span><span style=display:flex><span>            g_systemStatus.error_code <span style=color:#f92672>|=</span> ERROR_LOW_VOLTAGE;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* æ£€æŸ¥å­˜å‚¨ç©ºé—´ */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>DataLogger_GetFreeSpace</span>() <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1024</span>) {
</span></span><span style=display:flex><span>            g_systemStatus.error_code <span style=color:#f92672>|=</span> ERROR_STORAGE_FULL;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* ç³»ç»ŸçŠ¶æ€LEDæŒ‡ç¤º */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>SystemStatus_UpdateLED</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        lastMonitorTime <span style=color:#f92672>=</span> g_systemTick;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å—>ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å—<a hidden class=anchor aria-hidden=true href=#ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å—>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @file sensor_manager.c
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å—
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;sensor_manager.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;adc.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;tim.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;i2c.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* ä¼ æ„Ÿå™¨æ ¡å‡†å‚æ•° */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> offset;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> scale;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> filter_coefficient;
</span></span><span style=display:flex><span>} SensorCalibration_t;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> SensorCalibration_t tempCalib <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>0.1</span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> SensorCalibration_t pressureCalib <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>0.1</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief æ¸©åº¦ä¼ æ„Ÿå™¨è¯»å– (PT100)
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>SensorManager_ReadTemperature</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span> filteredTemp <span style=color:#f92672>=</span> <span style=color:#ae81ff>25.0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> adcValue;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> voltage, resistance, temperature;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* è¯»å–ADCå€¼ */</span>
</span></span><span style=display:flex><span>    adcValue <span style=color:#f92672>=</span> <span style=color:#a6e22e>ADC_ReadChannel</span>(ADC_CHANNEL_TEMP);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* è½¬æ¢ä¸ºç”µå‹ */</span>
</span></span><span style=display:flex><span>    voltage <span style=color:#f92672>=</span> (<span style=color:#66d9ef>float</span>)adcValue <span style=color:#f92672>*</span> <span style=color:#ae81ff>3.3f</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>4096.0f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* è®¡ç®—PT100ç”µé˜» */</span>
</span></span><span style=display:flex><span>    resistance <span style=color:#f92672>=</span> voltage <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000.0f</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>1.0f</span>; <span style=color:#75715e>/* 1mAæ’æµæº */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* PT100ç”µé˜»-æ¸©åº¦è½¬æ¢ (Callendar-Van Dusenæ–¹ç¨‹) */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (resistance <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>100.0</span>) {
</span></span><span style=display:flex><span>        temperature <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>242.02</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2.2228</span> <span style=color:#f92672>*</span> resistance
</span></span><span style=display:flex><span>                   <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.00258</span> <span style=color:#f92672>*</span> resistance <span style=color:#f92672>*</span> resistance;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        temperature <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>242.02</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2.2228</span> <span style=color:#f92672>*</span> resistance;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* åº”ç”¨æ ¡å‡†å‚æ•° */</span>
</span></span><span style=display:flex><span>    temperature <span style=color:#f92672>=</span> temperature <span style=color:#f92672>*</span> tempCalib.scale <span style=color:#f92672>+</span> tempCalib.offset;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* è½¯ä»¶æ»¤æ³¢ */</span>
</span></span><span style=display:flex><span>    filteredTemp <span style=color:#f92672>=</span> filteredTemp <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> tempCalib.filter_coefficient)
</span></span><span style=display:flex><span>                <span style=color:#f92672>+</span> temperature <span style=color:#f92672>*</span> tempCalib.filter_coefficient;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> filteredTemp;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief å‹åŠ›ä¼ æ„Ÿå™¨è¯»å– (4-20mA)
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>SensorManager_ReadPressure</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span> filteredPressure <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> adcValue;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> current, pressure;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* è¯»å–ADCå€¼ */</span>
</span></span><span style=display:flex><span>    adcValue <span style=color:#f92672>=</span> <span style=color:#a6e22e>ADC_ReadChannel</span>(ADC_CHANNEL_PRESSURE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* è½¬æ¢ä¸ºç”µæµ (4-20mAå¯¹åº”0.8-4Vç”µå‹) */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> voltage <span style=color:#f92672>=</span> (<span style=color:#66d9ef>float</span>)adcValue <span style=color:#f92672>*</span> <span style=color:#ae81ff>3.3f</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>4096.0f</span>;
</span></span><span style=display:flex><span>    current <span style=color:#f92672>=</span> (voltage <span style=color:#f92672>-</span> <span style=color:#ae81ff>0.8f</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>5.0f</span>; <span style=color:#75715e>/* 4-20mA */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* è½¬æ¢ä¸ºå‹åŠ›å€¼ (0-10Bar) */</span>
</span></span><span style=display:flex><span>    pressure <span style=color:#f92672>=</span> (current <span style=color:#f92672>-</span> <span style=color:#ae81ff>4.0f</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>10.0f</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>16.0f</span>; <span style=color:#75715e>/* 4-20mA -&gt; 0-10Bar */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* è´Ÿå€¼å¤„ç† */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pressure <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0.0</span>) pressure <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* åº”ç”¨æ ¡å‡†å‚æ•° */</span>
</span></span><span style=display:flex><span>    pressure <span style=color:#f92672>=</span> pressure <span style=color:#f92672>*</span> pressureCalib.scale <span style=color:#f92672>+</span> pressureCalib.offset;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* è½¯ä»¶æ»¤æ³¢ */</span>
</span></span><span style=display:flex><span>    filteredPressure <span style=color:#f92672>=</span> filteredPressure <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> pressureCalib.filter_coefficient)
</span></span><span style=display:flex><span>                     <span style=color:#f92672>+</span> pressure <span style=color:#f92672>*</span> pressureCalib.filter_coefficient;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> filteredPressure;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief æµé‡ä¼ æ„Ÿå™¨è¯»å– (è„‰å†²è¾“å‡º)
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>SensorManager_ReadFlowRate</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>uint32_t</span> lastPulseCount <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>uint32_t</span> lastReadTime <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>float</span> flowRate <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> currentPulseCount, pulseDelta;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> timeDelta;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> frequency;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* è·å–å½“å‰è„‰å†²è®¡æ•° */</span>
</span></span><span style=display:flex><span>    currentPulseCount <span style=color:#f92672>=</span> <span style=color:#a6e22e>TIM_GetPulseCount</span>(TIM_FLOW);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* è®¡ç®—æ—¶é—´å·® */</span>
</span></span><span style=display:flex><span>    timeDelta <span style=color:#f92672>=</span> g_systemTick <span style=color:#f92672>-</span> lastReadTime;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (timeDelta <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* è®¡ç®—è„‰å†²å¢é‡ */</span>
</span></span><span style=display:flex><span>        pulseDelta <span style=color:#f92672>=</span> currentPulseCount <span style=color:#f92672>-</span> lastPulseCount;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* è®¡ç®—é¢‘ç‡ (Hz) */</span>
</span></span><span style=display:flex><span>        frequency <span style=color:#f92672>=</span> (<span style=color:#66d9ef>float</span>)pulseDelta <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000.0f</span> <span style=color:#f92672>/</span> (<span style=color:#66d9ef>float</span>)timeDelta;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* è½¬æ¢ä¸ºæµé‡ (L/min) */</span>
</span></span><span style=display:flex><span>        flowRate <span style=color:#f92672>=</span> frequency <span style=color:#f92672>*</span> <span style=color:#ae81ff>60.0f</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>100.0f</span>; <span style=color:#75715e>/* 100è„‰å†²/L */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* æ›´æ–°å†å²è®°å½• */</span>
</span></span><span style=display:flex><span>        lastPulseCount <span style=color:#f92672>=</span> currentPulseCount;
</span></span><span style=display:flex><span>        lastReadTime <span style=color:#f92672>=</span> g_systemTick;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> flowRate;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief æŒ¯åŠ¨ä¼ æ„Ÿå™¨è¯»å– (IEPE)
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>SensorManager_ReadVibration</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> adcValue;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> voltage, rmsValue;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* è¯»å–ADCå€¼ */</span>
</span></span><span style=display:flex><span>    adcValue <span style=color:#f92672>=</span> <span style=color:#a6e22e>ADC_ReadChannel</span>(ADC_CHANNEL_VIBRATION);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* è½¬æ¢ä¸ºç”µå‹ */</span>
</span></span><span style=display:flex><span>    voltage <span style=color:#f92672>=</span> (<span style=color:#66d9ef>float</span>)adcValue <span style=color:#f92672>*</span> <span style=color:#ae81ff>3.3f</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>4096.0f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* è®¡ç®—RMSå€¼ */</span>
</span></span><span style=display:flex><span>    rmsValue <span style=color:#f92672>=</span> <span style=color:#a6e22e>Vibration_CalculateRMS</span>(voltage);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* è½¬æ¢ä¸ºåŠ é€Ÿåº¦å€¼ (g) */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> acceleration <span style=color:#f92672>=</span> rmsValue <span style=color:#f92672>*</span> <span style=color:#ae81ff>10.0f</span>; <span style=color:#75715e>/* 10g/Vçµæ•åº¦ */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> acceleration;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=modbusé€šä¿¡æ¨¡å—>Modbusé€šä¿¡æ¨¡å—<a hidden class=anchor aria-hidden=true href=#modbusé€šä¿¡æ¨¡å—>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @file modbus_server.c
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief ModbusæœåŠ¡å™¨å®ç°
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;modbus_server.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;usart.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;ethernet.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Modbuså¯„å­˜å™¨æ˜ å°„ */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>union</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint16_t</span> holding_registers[<span style=color:#ae81ff>100</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint16_t</span> input_registers[<span style=color:#ae81ff>100</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint16_t</span> coils[<span style=color:#ae81ff>100</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint16_t</span> discrete_inputs[<span style=color:#ae81ff>100</span>];
</span></span><span style=display:flex><span>    } registers;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> raw[<span style=color:#ae81ff>400</span>];
</span></span><span style=display:flex><span>} ModbusMemoryMap_t;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> ModbusMemoryMap_t g_modbusMemory;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief Modbuså¯„å­˜å™¨æ˜ å°„
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ModbusServer_UpdateRegisters</span>(SensorData_t<span style=color:#f92672>*</span> sensorData)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* è¾“å…¥å¯„å­˜å™¨ (åªè¯») */</span>
</span></span><span style=display:flex><span>    g_modbusMemory.registers.input_registers[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        (<span style=color:#66d9ef>uint16_t</span>)(sensorData<span style=color:#f92672>-&gt;</span>temperature <span style=color:#f92672>*</span> <span style=color:#ae81ff>10.0</span>);  <span style=color:#75715e>// æ¸©åº¦ (0.1Â°C)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    g_modbusMemory.registers.input_registers[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        (<span style=color:#66d9ef>uint16_t</span>)(sensorData<span style=color:#f92672>-&gt;</span>pressure <span style=color:#f92672>*</span> <span style=color:#ae81ff>100.0</span>);    <span style=color:#75715e>// å‹åŠ› (0.01Bar)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    g_modbusMemory.registers.input_registers[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        (<span style=color:#66d9ef>uint16_t</span>)(sensorData<span style=color:#f92672>-&gt;</span>flow_rate <span style=color:#f92672>*</span> <span style=color:#ae81ff>10.0</span>);    <span style=color:#75715e>// æµé‡ (0.1L/min)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    g_modbusMemory.registers.input_registers[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        (<span style=color:#66d9ef>uint16_t</span>)(sensorData<span style=color:#f92672>-&gt;</span>vibration <span style=color:#f92672>*</span> <span style=color:#ae81ff>100.0</span>);   <span style=color:#75715e>// æŒ¯åŠ¨ (0.01g)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* ä¿æŒå¯„å­˜å™¨ (è¯»å†™) */</span>
</span></span><span style=display:flex><span>    g_modbusMemory.registers.holding_registers[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        (<span style=color:#66d9ef>uint16_t</span>)(g_systemStatus.mode);            <span style=color:#75715e>// è¿è¡Œæ¨¡å¼
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    g_modbusMemory.registers.holding_registers[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        (<span style=color:#66d9ef>uint16_t</span>)(g_systemStatus.error_code);      <span style=color:#75715e>// é”™è¯¯ä»£ç 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    g_modbusMemory.registers.holding_registers[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        (<span style=color:#66d9ef>uint16_t</span>)(g_systemStatus.uptime);          <span style=color:#75715e>// è¿è¡Œæ—¶é—´
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief å¤„ç†Modbus RTUè¯·æ±‚
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ModbusServer_ProcessRTU</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>uint8_t</span> rxBuffer[<span style=color:#ae81ff>256</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>uint8_t</span> txBuffer[<span style=color:#ae81ff>256</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> rxLength, txLength;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* æ¥æ”¶æ•°æ® */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>UART_ReceiveBuffer</span>(<span style=color:#f92672>&amp;</span>huart1, rxBuffer, <span style=color:#f92672>&amp;</span>rxLength)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* è§£æModbusè¯·æ±‚ */</span>
</span></span><span style=display:flex><span>        ModbusRequest_t request;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>Modbus_ParseRequest</span>(rxBuffer, rxLength, <span style=color:#f92672>&amp;</span>request)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>/* å¤„ç†è¯·æ±‚ */</span>
</span></span><span style=display:flex><span>            ModbusResponse_t response;
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Modbus_ProcessRequest</span>(<span style=color:#f92672>&amp;</span>request, <span style=color:#f92672>&amp;</span>response);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>/* ç”Ÿæˆå“åº”å¸§ */</span>
</span></span><span style=display:flex><span>            txLength <span style=color:#f92672>=</span> <span style=color:#a6e22e>Modbus_GenerateResponse</span>(<span style=color:#f92672>&amp;</span>response, txBuffer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>/* å‘é€å“åº” */</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>UART_Transmit</span>(<span style=color:#f92672>&amp;</span>huart1, txBuffer, txLength);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief å¤„ç†Modbus TCPè¯·æ±‚
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ModbusServer_ProcessTCP</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* TCPé€šä¿¡å¤„ç† (ç®€åŒ–å®ç°) */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> tcpBuffer[<span style=color:#ae81ff>512</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> tcpLength;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>Ethernet_ReceiveData</span>(tcpBuffer, <span style=color:#f92672>&amp;</span>tcpLength)) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* è§£æMBAPå¤´éƒ¨å’ŒModbus PDU */</span>
</span></span><span style=display:flex><span>        ModbusTCP_Request_t tcpRequest;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>ModbusTCP_ParseRequest</span>(tcpBuffer, tcpLength, <span style=color:#f92672>&amp;</span>tcpRequest)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>/* å¤„ç†Modbusè¯·æ±‚ */</span>
</span></span><span style=display:flex><span>            ModbusResponse_t response;
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Modbus_ProcessRequest</span>(<span style=color:#f92672>&amp;</span>tcpRequest.modbus_request, <span style=color:#f92672>&amp;</span>response);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>/* ç”ŸæˆTCPå“åº” */</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>uint16_t</span> responseLength;
</span></span><span style=display:flex><span>            responseLength <span style=color:#f92672>=</span> <span style=color:#a6e22e>ModbusTCP_GenerateResponse</span>(
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;</span>tcpRequest, <span style=color:#f92672>&amp;</span>response, tcpBuffer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>/* å‘é€TCPå“åº” */</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Ethernet_TransmitData</span>(tcpBuffer, responseLength);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief å¤„ç†ModbusåŠŸèƒ½ç 
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Modbus_ProcessRequest</span>(ModbusRequest_t<span style=color:#f92672>*</span> request, ModbusResponse_t<span style=color:#f92672>*</span> response)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    response<span style=color:#f92672>-&gt;</span>slave_address <span style=color:#f92672>=</span> request<span style=color:#f92672>-&gt;</span>slave_address;
</span></span><span style=display:flex><span>    response<span style=color:#f92672>-&gt;</span>function_code <span style=color:#f92672>=</span> request<span style=color:#f92672>-&gt;</span>function_code;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (request<span style=color:#f92672>-&gt;</span>function_code) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> MODBUS_FC_READ_HOLDING_REGISTERS:
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Modbus_ReadHoldingRegisters</span>(request, response);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> MODBUS_FC_READ_INPUT_REGISTERS:
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Modbus_ReadInputRegisters</span>(request, response);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> MODBUS_FC_WRITE_SINGLE_REGISTER:
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Modbus_WriteSingleRegister</span>(request, response);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> MODBUS_FC_WRITE_MULTIPLE_REGISTERS:
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Modbus_WriteMultipleRegisters</span>(request, response);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            response<span style=color:#f92672>-&gt;</span>function_code <span style=color:#f92672>|=</span> <span style=color:#ae81ff>0x80</span>; <span style=color:#75715e>// å¼‚å¸¸å“åº”
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            response<span style=color:#f92672>-&gt;</span>data[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> MODBUS_EXCEPTION_ILLEGAL_FUNCTION;
</span></span><span style=display:flex><span>            response<span style=color:#f92672>-&gt;</span>data_length <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=-æ•°æ®è®°å½•ä¸åˆ†æ>ğŸ“Š æ•°æ®è®°å½•ä¸åˆ†æ<a hidden class=anchor aria-hidden=true href=#-æ•°æ®è®°å½•ä¸åˆ†æ>#</a></h2><h3 id=æ•°æ®è®°å½•åŠŸèƒ½>æ•°æ®è®°å½•åŠŸèƒ½<a hidden class=anchor aria-hidden=true href=#æ•°æ®è®°å½•åŠŸèƒ½>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @file data_logger.c
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief æ•°æ®è®°å½•æ¨¡å—
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;data_logger.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;flash.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;rtc.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* æ•°æ®è®°å½•ç»“æ„ */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> timestamp;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> temperature;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> pressure;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> flow_rate;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> vibration;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> system_status;
</span></span><span style=display:flex><span>} DataRecord_t;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* å†å²æ•°æ®ç¼“å†²åŒº */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define DATA_BUFFER_SIZE  1000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> DataRecord_t g_dataBuffer[DATA_BUFFER_SIZE];
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>uint16_t</span> g_dataBufferIndex <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>uint32_t</span> g_totalRecords <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief è®°å½•ä¼ æ„Ÿå™¨æ•°æ®
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>DataLogger_RecordData</span>(SensorData_t<span style=color:#f92672>*</span> sensorData)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    DataRecord_t<span style=color:#f92672>*</span> record <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>g_dataBuffer[g_dataBufferIndex];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* å¡«å……æ•°æ®è®°å½• */</span>
</span></span><span style=display:flex><span>    record<span style=color:#f92672>-&gt;</span>timestamp <span style=color:#f92672>=</span> <span style=color:#a6e22e>RTC_GetTimestamp</span>();
</span></span><span style=display:flex><span>    record<span style=color:#f92672>-&gt;</span>temperature <span style=color:#f92672>=</span> sensorData<span style=color:#f92672>-&gt;</span>temperature;
</span></span><span style=display:flex><span>    record<span style=color:#f92672>-&gt;</span>pressure <span style=color:#f92672>=</span> sensorData<span style=color:#f92672>-&gt;</span>pressure;
</span></span><span style=display:flex><span>    record<span style=color:#f92672>-&gt;</span>flow_rate <span style=color:#f92672>=</span> sensorData<span style=color:#f92672>-&gt;</span>flow_rate;
</span></span><span style=display:flex><span>    record<span style=color:#f92672>-&gt;</span>vibration <span style=color:#f92672>=</span> sensorData<span style=color:#f92672>-&gt;</span>vibration;
</span></span><span style=display:flex><span>    record<span style=color:#f92672>-&gt;</span>system_status <span style=color:#f92672>=</span> g_systemStatus.error_code;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* æ›´æ–°ç¼“å†²åŒºç´¢å¼• */</span>
</span></span><span style=display:flex><span>    g_dataBufferIndex <span style=color:#f92672>=</span> (g_dataBufferIndex <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>%</span> DATA_BUFFER_SIZE;
</span></span><span style=display:flex><span>    g_totalRecords<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* æ£€æŸ¥æ˜¯å¦éœ€è¦ä¿å­˜åˆ°Flash */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (g_dataBufferIndex <span style=color:#f92672>%</span> <span style=color:#ae81ff>100</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DataLogger_SaveToFlash</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief æ•°æ®æ»¤æ³¢å¤„ç†
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>DataLogger_FilterSensorData</span>(SensorData_t<span style=color:#f92672>*</span> sensorData)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> SensorData_t filterBuffer[<span style=color:#ae81ff>5</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>uint8_t</span> filterIndex <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* æ›´æ–°æ»¤æ³¢ç¼“å†²åŒº */</span>
</span></span><span style=display:flex><span>    filterBuffer[filterIndex] <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>sensorData;
</span></span><span style=display:flex><span>    filterIndex <span style=color:#f92672>=</span> (filterIndex <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>%</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* è®¡ç®—ç§»åŠ¨å¹³å‡å€¼ */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> tempSum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>, pressureSum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> flowSum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>, vibrationSum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>5</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        tempSum <span style=color:#f92672>+=</span> filterBuffer[i].temperature;
</span></span><span style=display:flex><span>        pressureSum <span style=color:#f92672>+=</span> filterBuffer[i].pressure;
</span></span><span style=display:flex><span>        flowSum <span style=color:#f92672>+=</span> filterBuffer[i].flow_rate;
</span></span><span style=display:flex><span>        vibrationSum <span style=color:#f92672>+=</span> filterBuffer[i].vibration;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sensorData<span style=color:#f92672>-&gt;</span>temperature <span style=color:#f92672>=</span> tempSum <span style=color:#f92672>/</span> <span style=color:#ae81ff>5.0</span>;
</span></span><span style=display:flex><span>    sensorData<span style=color:#f92672>-&gt;</span>pressure <span style=color:#f92672>=</span> pressureSum <span style=color:#f92672>/</span> <span style=color:#ae81ff>5.0</span>;
</span></span><span style=display:flex><span>    sensorData<span style=color:#f92672>-&gt;</span>flow_rate <span style=color:#f92672>=</span> flowSum <span style=color:#f92672>/</span> <span style=color:#ae81ff>5.0</span>;
</span></span><span style=display:flex><span>    sensorData<span style=color:#f92672>-&gt;</span>vibration <span style=color:#f92672>=</span> vibrationSum <span style=color:#f92672>/</span> <span style=color:#ae81ff>5.0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief æ•°æ®æœ‰æ•ˆæ€§æ£€æŸ¥
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>DataLogger_ValidateSensorData</span>(SensorData_t<span style=color:#f92672>*</span> sensorData)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> isValid <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* æ¸©åº¦èŒƒå›´æ£€æŸ¥ */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (sensorData<span style=color:#f92672>-&gt;</span>temperature <span style=color:#f92672>&lt;</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>40.0</span> <span style=color:#f92672>||</span> sensorData<span style=color:#f92672>-&gt;</span>temperature <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>125.0</span>) {
</span></span><span style=display:flex><span>        sensorData<span style=color:#f92672>-&gt;</span>temperature <span style=color:#f92672>=</span> <span style=color:#ae81ff>25.0</span>; <span style=color:#75715e>// é»˜è®¤å€¼
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        isValid <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* å‹åŠ›èŒƒå›´æ£€æŸ¥ */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (sensorData<span style=color:#f92672>-&gt;</span>pressure <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0.0</span> <span style=color:#f92672>||</span> sensorData<span style=color:#f92672>-&gt;</span>pressure <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>20.0</span>) {
</span></span><span style=display:flex><span>        sensorData<span style=color:#f92672>-&gt;</span>pressure <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>        isValid <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* æµé‡èŒƒå›´æ£€æŸ¥ */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (sensorData<span style=color:#f92672>-&gt;</span>flow_rate <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0.0</span> <span style=color:#f92672>||</span> sensorData<span style=color:#f92672>-&gt;</span>flow_rate <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1000.0</span>) {
</span></span><span style=display:flex><span>        sensorData<span style=color:#f92672>-&gt;</span>flow_rate <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>        isValid <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* æŒ¯åŠ¨èŒƒå›´æ£€æŸ¥ */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (sensorData<span style=color:#f92672>-&gt;</span>vibration <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0.0</span> <span style=color:#f92672>||</span> sensorData<span style=color:#f92672>-&gt;</span>vibration <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>50.0</span>) {
</span></span><span style=display:flex><span>        sensorData<span style=color:#f92672>-&gt;</span>vibration <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>        isValid <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> isValid;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=-ç³»ç»Ÿæµ‹è¯•ä¸éªŒè¯>ğŸ”§ ç³»ç»Ÿæµ‹è¯•ä¸éªŒè¯<a hidden class=anchor aria-hidden=true href=#-ç³»ç»Ÿæµ‹è¯•ä¸éªŒè¯>#</a></h2><h3 id=åŠŸèƒ½æµ‹è¯•æ¸…å•>åŠŸèƒ½æµ‹è¯•æ¸…å•<a hidden class=anchor aria-hidden=true href=#åŠŸèƒ½æµ‹è¯•æ¸…å•>#</a></h3><pre tabindex=0><code>ç¡¬ä»¶æµ‹è¯•:
âœ“ ç”µæºè¾“å…¥æµ‹è¯• (24V DC Â±10%)
âœ“ å·¥ä½œæ¸©åº¦æµ‹è¯• (-20Â°C ~ +70Â°C)
âœ“ EMIæŠ—å¹²æ‰°æµ‹è¯• (IEC 61000-4-3)
âœ“ é˜²æŠ¤ç­‰çº§æµ‹è¯• (IP65)
âœ“ æŒ¯åŠ¨æµ‹è¯• (IEC 60068-2-6)

è½¯ä»¶æµ‹è¯•:
âœ“ ä¼ æ„Ÿå™¨ç²¾åº¦æµ‹è¯• (Â±0.1%)
âœ“ Modbusé€šä¿¡æµ‹è¯• (RTU/TCP)
âœ“ æ•°æ®è®°å½•æµ‹è¯• (1000æ¡/ç§’)
âœ“ çœ‹é—¨ç‹—åŠŸèƒ½æµ‹è¯•
âœ“ æ•…éšœæ¢å¤æµ‹è¯•

æ€§èƒ½æŒ‡æ ‡:
âœ“ å¯åŠ¨æ—¶é—´: &lt; 2ç§’
âœ“ æ•°æ®æ›´æ–°é¢‘ç‡: 10Hz
âœ“ é€šä¿¡å“åº”æ—¶é—´: &lt; 100ms
âœ“ å­˜å‚¨å®¹é‡: 10,000æ¡è®°å½•
âœ“ åŠŸè€—: &lt; 5W
</code></pre><h3 id=ç°åœºæµ‹è¯•ç»“æœ>ç°åœºæµ‹è¯•ç»“æœ<a hidden class=anchor aria-hidden=true href=#ç°åœºæµ‹è¯•ç»“æœ>#</a></h3><pre tabindex=0><code>æµ‹è¯•ç¯å¢ƒ: å·¥ä¸šæ³µç«™ç°åœº
æµ‹è¯•æ—¶é—´: 72å°æ—¶è¿ç»­è¿è¡Œ

ä¼ æ„Ÿå™¨æµ‹è¯•ç»“æœ:
- æ¸©åº¦æµ‹é‡ç²¾åº¦: Â±0.05Â°C (PT100, 0-100Â°CèŒƒå›´)
- å‹åŠ›æµ‹é‡ç²¾åº¦: Â±0.2%FS (4-20mA, 0-10Bar)
- æµé‡æµ‹é‡ç²¾åº¦: Â±1.0% (è„‰å†²è¾“å‡º, 0-500L/min)
- æŒ¯åŠ¨æµ‹é‡ç²¾åº¦: Â±5% (IEPE, 0-10g)

é€šä¿¡æµ‹è¯•ç»“æœ:
- Modbus RTU: 9600bps, 0é”™è¯¯
- Modbus TCP: 100Mbps, &lt;10mså»¶è¿Ÿ
- æ•°æ®å®Œæ•´æ€§: 99.99%
- è¿æ¥ç¨³å®šæ€§: 72å°æ—¶æ— æ–­çº¿

ç³»ç»Ÿç¨³å®šæ€§:
- è¿ç»­è¿è¡Œæ—¶é—´: 72å°æ—¶
- å†…å­˜ä½¿ç”¨ç‡: 45%
- CPUä½¿ç”¨ç‡: 30%
- å­˜å‚¨ç©ºé—´ä½¿ç”¨: 23%
</code></pre><h2 id=-é¡¹ç›®åº”ç”¨åœºæ™¯>ğŸ“ˆ é¡¹ç›®åº”ç”¨åœºæ™¯<a hidden class=anchor aria-hidden=true href=#-é¡¹ç›®åº”ç”¨åœºæ™¯>#</a></h2><h3 id=å·¥ä¸šåº”ç”¨æ¡ˆä¾‹>å·¥ä¸šåº”ç”¨æ¡ˆä¾‹<a hidden class=anchor aria-hidden=true href=#å·¥ä¸šåº”ç”¨æ¡ˆä¾‹>#</a></h3><ol><li><p><strong>æ³µç«™ç›‘æ§ç³»ç»Ÿ</strong></p><ul><li>å‹åŠ›ã€æµé‡ã€æ¸©åº¦å®æ—¶ç›‘æ§</li><li>è®¾å¤‡çŠ¶æ€è¿œç¨‹è¯Šæ–­</li><li>èƒ½è€—åˆ†æå’Œä¼˜åŒ–</li></ul></li><li><p><strong>ç”Ÿäº§çº¿è®¾å¤‡æ§åˆ¶</strong></p><ul><li>è®¾å¤‡è¿è¡Œå‚æ•°ç›‘æ§</li><li>è´¨é‡æ•°æ®é‡‡é›†</li><li>é¢„é˜²æ€§ç»´æŠ¤æ”¯æŒ</li></ul></li><li><p><strong>ç¯å¢ƒç›‘æµ‹ç³»ç»Ÿ</strong></p><ul><li>æ¸©æ¹¿åº¦ã€æ°”ä½“æµ“åº¦ç›‘æµ‹</li><li>æ•°æ®è®°å½•å’ŒæŠ¥è­¦</li><li>è¿œç¨‹æ•°æ®è®¿é—®</li></ul></li></ol><h2 id=-æŠ€æœ¯åˆ›æ–°ç‚¹>ğŸ“ æŠ€æœ¯åˆ›æ–°ç‚¹<a hidden class=anchor aria-hidden=true href=#-æŠ€æœ¯åˆ›æ–°ç‚¹>#</a></h2><ol><li><strong>å¤šä¼ æ„Ÿå™¨èåˆ</strong>: é›†æˆæ¸©åº¦ã€å‹åŠ›ã€æµé‡ã€æŒ¯åŠ¨ç­‰å¤šç§ä¼ æ„Ÿå™¨</li><li><strong>å·¥ä¸šé€šä¿¡åè®®</strong>: æ”¯æŒModbus RTU/TCPæ ‡å‡†å·¥ä¸šåè®®</li><li><strong>æœ¬åœ°æ™ºèƒ½å¤„ç†</strong>: è¾¹ç¼˜è®¡ç®—èƒ½åŠ›ï¼Œå‡å°‘ä¸Šä½æœºè´Ÿè½½</li><li><strong>é«˜å¯é æ€§è®¾è®¡</strong>: çœ‹é—¨ç‹—ã€ç”µæºç›‘æ§ã€EMCé˜²æŠ¤</li><li><strong>çµæ´»é…ç½®</strong>: é€šè¿‡Modbuså¯„å­˜å™¨å¯åœ¨çº¿é…ç½®å‚æ•°</li></ol><hr><p><strong>è¯¥æ§åˆ¶å•å…ƒå·²æˆåŠŸåº”ç”¨äºå¤šä¸ªå·¥ä¸šç°åœºï¼Œä¸ºè®¾å¤‡ç›‘æ§å’Œæ•°æ®åˆ†ææä¾›äº†å¯é çš„æŠ€æœ¯æ”¯æ’‘ã€‚</strong></p><p><em>é¡¹ç›®ä»£ç å·²é€šè¿‡ä¸¥æ ¼çš„ä»£ç å®¡æŸ¥å’Œæµ‹è¯•éªŒè¯ï¼Œç¬¦åˆå·¥ä¸šçº§åº”ç”¨æ ‡å‡†ã€‚</em></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://hugo-maker-blog.vercel.app/tags/stm32/>STM32</a></li><li><a href=https://hugo-maker-blog.vercel.app/tags/c%E8%AF%AD%E8%A8%80/>Cè¯­è¨€</a></li><li><a href=https://hugo-maker-blog.vercel.app/tags/modbus/>Modbus</a></li><li><a href=https://hugo-maker-blog.vercel.app/tags/%E4%BC%A0%E6%84%9F%E5%99%A8/>ä¼ æ„Ÿå™¨</a></li><li><a href=https://hugo-maker-blog.vercel.app/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%8E%A7%E5%88%B6/>åµŒå…¥å¼æ§åˆ¶</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒ on x" href="https://x.com/intent/tweet/?text=%e6%99%ba%e8%83%bd%e8%ae%be%e5%a4%87%e6%8e%a7%e5%88%b6%e5%8d%95%e5%85%83&amp;url=https%3a%2f%2fhugo-maker-blog.vercel.app%2fprojects%2fembedded-control-unit%2f&amp;hashtags=STM32%2cC%e8%af%ad%e8%a8%80%2cModbus%2c%e4%bc%a0%e6%84%9f%e5%99%a8%2c%e5%b5%8c%e5%85%a5%e5%bc%8f%e6%8e%a7%e5%88%b6"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒ on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fhugo-maker-blog.vercel.app%2fprojects%2fembedded-control-unit%2f&amp;title=%e6%99%ba%e8%83%bd%e8%ae%be%e5%a4%87%e6%8e%a7%e5%88%b6%e5%8d%95%e5%85%83&amp;summary=%e6%99%ba%e8%83%bd%e8%ae%be%e5%a4%87%e6%8e%a7%e5%88%b6%e5%8d%95%e5%85%83&amp;source=https%3a%2f%2fhugo-maker-blog.vercel.app%2fprojects%2fembedded-control-unit%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒ on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fhugo-maker-blog.vercel.app%2fprojects%2fembedded-control-unit%2f&title=%e6%99%ba%e8%83%bd%e8%ae%be%e5%a4%87%e6%8e%a7%e5%88%b6%e5%8d%95%e5%85%83"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒ on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fhugo-maker-blog.vercel.app%2fprojects%2fembedded-control-unit%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒ on whatsapp" href="https://api.whatsapp.com/send?text=%e6%99%ba%e8%83%bd%e8%ae%be%e5%a4%87%e6%8e%a7%e5%88%b6%e5%8d%95%e5%85%83%20-%20https%3a%2f%2fhugo-maker-blog.vercel.app%2fprojects%2fembedded-control-unit%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒ on telegram" href="https://telegram.me/share/url?text=%e6%99%ba%e8%83%bd%e8%ae%be%e5%a4%87%e6%8e%a7%e5%88%b6%e5%8d%95%e5%85%83&amp;url=https%3a%2f%2fhugo-maker-blog.vercel.app%2fprojects%2fembedded-control-unit%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒ on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e6%99%ba%e8%83%bd%e8%ae%be%e5%a4%87%e6%8e%a7%e5%88%b6%e5%8d%95%e5%85%83&u=https%3a%2f%2fhugo-maker-blog.vercel.app%2fprojects%2fembedded-control-unit%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://hugo-maker-blog.vercel.app/>Automation & Industrial Control Technician</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>
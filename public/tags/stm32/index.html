<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>STM32 | Automation &amp; Industrial Control Technician</title>
<meta name="keywords" content="">
<meta name="description" content="ä¸“ä¸šçš„è‡ªåŠ¨åŒ–ä¸å·¥ä¸šæ§åˆ¶æŠ€æœ¯å‘˜ | PLCç¼–ç¨‹ | åµŒå…¥å¼æ§åˆ¶ | SolidWorksè®¾è®¡">
<meta name="author" content="dmk69">
<link rel="canonical" href="http://localhost:1313/tags/stm32/">
<meta name="google-site-verification" content="XYZabc">
<meta name="yandex-verification" content="XYZabc">
<meta name="msvalidate.01" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css" integrity="sha256-NDzEgLn/yPBMy&#43;XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/tags/stm32/index.xml" title="rss">
<link rel="alternate" hreflang="en" href="http://localhost:1313/tags/stm32/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="http://localhost:1313/tags/stm32/">
  <meta property="og:site_name" content="Automation & Industrial Control Technician">
  <meta property="og:title" content="STM32">
  <meta property="og:description" content="ä¸“ä¸šçš„è‡ªåŠ¨åŒ–ä¸å·¥ä¸šæ§åˆ¶æŠ€æœ¯å‘˜ | PLCç¼–ç¨‹ | åµŒå…¥å¼æ§åˆ¶ | SolidWorksè®¾è®¡">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="website">
      <meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name="twitter:title" content="STM32">
<meta name="twitter:description" content="ä¸“ä¸šçš„è‡ªåŠ¨åŒ–ä¸å·¥ä¸šæ§åˆ¶æŠ€æœ¯å‘˜ | PLCç¼–ç¨‹ | åµŒå…¥å¼æ§åˆ¶ | SolidWorksè®¾è®¡">

</head>
<body class="list" id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                <img src="http://localhost:1313/apple-touch-icon.png" alt="" aria-label="logo"
                    height="35">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/projects/" title="é¡¹ç›®å±•ç¤º">
                    <span>é¡¹ç›®å±•ç¤º</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/posts/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="æ ‡ç­¾">
                    <span>æ ‡ç­¾</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="å…³äº">
                    <span>å…³äº</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;Â»&nbsp;<a href="http://localhost:1313/tags/">Tags</a></div>
  <h1>
    STM32
    <a href="/tags/stm32/index.xml" title="RSS" aria-label="RSS">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round" height="23">
        <path d="M4 11a9 9 0 0 1 9 9" />
        <path d="M4 4a16 16 0 0 1 16 16" />
        <circle cx="5" cy="19" r="1" />
      </svg>
    </a>
  </h1>
</header>

<article class="post-entry tag-entry"> 
<figure class="entry-cover">
        <img loading="lazy" src="https://images.unsplash.com/photo-1537497711-4ba6054142f0?w=800&amp;h=400&amp;fit=crop" alt="STM32å¼€å‘æ¿">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">STM32å®Œæ•´å­¦ä¹ æŒ‡å—ï¼šä»å…¥é—¨åˆ°ç²¾é€š
    </h2>
  </header>
  <div class="entry-content">
    <p>ğŸ”§ STM32å®Œæ•´å­¦ä¹ æŒ‡å—ï¼šä»å…¥é—¨åˆ°ç²¾é€š STM32æ˜¯STå…¬å¸æ¨å‡ºçš„åŸºäºARM Cortex-Må†…æ ¸çš„32ä½å¾®æ§åˆ¶å™¨ç³»åˆ—ï¼Œåœ¨å·¥ä¸šæ§åˆ¶ã€æ¶ˆè´¹ç”µå­ã€ç‰©è”ç½‘ç­‰é¢†åŸŸæœ‰ç€å¹¿æ³›åº”ç”¨ã€‚æœ¬æŒ‡å—å°†å¸¦ä½ ä»é›¶åŸºç¡€é€æ­¥æŒæ¡STM32å¼€å‘ã€‚
ğŸ“š å­¦ä¹ è·¯å¾„è§„åˆ’ é˜¶æ®µä¸€ï¼šåŸºç¡€å…¥é—¨ (ç¬¬1-4å‘¨) 1.1 å¼€å‘ç¯å¢ƒæ­å»º # å¿…éœ€è½¯ä»¶ - STM32CubeIDE (æ¨è) æˆ– Keil MDK - STM32CubeMX (å›¾å½¢åŒ–é…ç½®å·¥å…·) - ST-Linké©±åŠ¨å’Œè°ƒè¯•å·¥å…· - ä¸²å£è°ƒè¯•åŠ©æ‰‹ (XShellã€MobaXtermç­‰) 1.2 ç¡¬ä»¶å‡†å¤‡ å¼€å‘æ¿å‹å· ä»·æ ¼ æ¨èåº¦ ç‰¹ç‚¹ STM32F103C8T6 ï¿¥15-25 â­â­â­â­â­ ç»å…¸å‹å·ï¼Œèµ„æ–™ä¸°å¯Œ STM32F407VGT6 ï¿¥60-80 â­â­â­â­ æ€§èƒ½å¼ºå¤§ï¼Œé€‚åˆé«˜çº§åº”ç”¨ STM32L051C8 ï¿¥20-30 â­â­â­ ä½åŠŸè€—ï¼Œé€‚åˆç”µæ± åº”ç”¨ 1.3 ç¬¬ä¸€ä¸ªç¨‹åºï¼šLEDé—ªçƒ /* main.c */ #include &#34;main.h&#34; int main(void) { HAL_Init(); SystemClock_Config(); // åˆå§‹åŒ–GPIO __HAL_RCC_GPIOC_CLK_ENABLE(); GPIO_InitTypeDef GPIO_InitStruct = {0}; GPIO_InitStruct.Pin = GPIO_PIN_13; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStruct); while (1) { HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET); HAL_Delay(500); HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET); HAL_Delay(500); } } é˜¶æ®µäºŒï¼šå¤–è®¾åº”ç”¨ (ç¬¬5-8å‘¨) 2.1 GPIOæ·±å…¥ç†è§£ è¾“å…¥è¾“å‡ºæ¨¡å¼é…ç½® ä¸­æ–­å’Œäº‹ä»¶å¤„ç† å¤ç”¨åŠŸèƒ½é…ç½® 2.2 å®šæ—¶å™¨åº”ç”¨ // PWMè¾“å‡ºé…ç½® void Timer_PWM_Init(void) { TIM_HandleTypeDef htim3; TIM_OC_InitTypeDef sConfigOC = {0}; htim3.Instance = TIM3; htim3.Init.Prescaler = 71; // 72MHz/72 = 1MHz htim3.Init.CounterMode = TIM_COUNTERMODE_UP; htim3.Init.Period = 999; // 1kHz htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; HAL_TIM_PWM_Init(&amp;htim3); sConfigOC.OCMode = TIM_OCMODE_PWM1; sConfigOC.Pulse = 499; // 50%å ç©ºæ¯” sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH; sConfigOC.OCFastMode = TIM_OCFAST_DISABLE; HAL_TIM_PWM_ConfigChannel(&amp;htim3, &amp;sConfigOC, TIM_CHANNEL_1); } 2.3 ä¸²å£é€šä¿¡ // UARTé…ç½® void UART_Init(void) { UART_HandleTypeDef huart1; huart1.Instance = USART1; huart1.Init.BaudRate = 115200; huart1.Init.WordLength = UART_WORDLENGTH_8B; huart1.Init.StopBits = UART_STOPBITS_1; huart1.Init.Parity = UART_PARITY_NONE; huart1.Init.Mode = UART_MODE_TX_RX; huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; HAL_UART_Init(&amp;huart1); } // å‘é€æ•°æ® uint8_t data[] = &#34;Hello STM32!\r\n&#34;; HAL_UART_Transmit(&amp;huart1, data, sizeof(data), 1000); é˜¶æ®µä¸‰ï¼šé«˜çº§åº”ç”¨ (ç¬¬9-12å‘¨) 3.1 ADCé‡‡æ · // ADCé…ç½® void ADC_Init(void) { ADC_HandleTypeDef hadc1; hadc1.Instance = ADC1; hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4; hadc1.Init.Resolution = ADC_RESOLUTION_12B; hadc1.Init.ScanConvMode = DISABLE; hadc1.Init.ContinuousConvMode = ENABLE; hadc1.Init.DiscontinuousConvMode = DISABLE; hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START; hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT; hadc1.Init.NbrOfConversion = 1; HAL_ADC_Init(&amp;hadc1); } // è¯»å–ADCå€¼ uint32_t ADC_Read(void) { HAL_ADC_Start(&amp;hadc1); HAL_ADC_PollForConversion(&amp;hadc1, 1000); return HAL_ADC_GetValue(&amp;hadc1); } 3.2 I2Cå’ŒSPIé€šä¿¡ // I2Cè¯»å–ä¼ æ„Ÿå™¨æ•°æ® HAL_StatusTypeDef I2C_Read_Sensor(uint8_t dev_addr, uint8_t reg_addr, uint8_t *data, uint16_t len) { HAL_I2C_Mem_Read(&amp;hi2c1, dev_addr, reg_addr, 1, data, len, 1000); return HAL_OK; } ğŸ“– å­¦ä¹ èµ„æºæ¨è å®˜æ–¹æ–‡æ¡£ STM32å‚è€ƒæ‰‹å†Œ HALåº“ç”¨æˆ·æ‰‹å†Œ è§†é¢‘æ•™ç¨‹ Bç«™: æ­£ç‚¹åŸå­ã€é‡ç«ã€å®‰ç¦è± YouTube: STM32å®˜æ–¹é¢‘é“ã€åµŒå…¥å¼ç³»ç»Ÿå¼€å‘è€… å¼€å‘æ¿æ¨è æ­£ç‚¹åŸå­F103: èµ„æ–™ä¸°å¯Œï¼Œé€‚åˆåˆå­¦è€… é‡ç«F407: æ•™ç¨‹ç³»ç»Ÿï¼Œé¡¹ç›®ä¸°å¯Œ å®‰ç¦è±Lç³»åˆ—: ä¸“æ³¨ä½åŠŸè€—åº”ç”¨ ğŸ› ï¸ å®è·µé¡¹ç›® é¡¹ç›®1ï¼šæ™ºèƒ½ç¯å¢ƒç›‘æµ‹å™¨ // å¤šä¼ æ„Ÿå™¨æ•°æ®é‡‡é›† typedef struct { float temperature; // æ¸©åº¦ float humidity; // æ¹¿åº¦ uint16_t light; // å…‰ç…§ uint16_t air_quality; // ç©ºæ°”è´¨é‡ } SensorData; void Read_All_Sensors(SensorData *data) { data-&gt;temperature = DHT11_Read_Temperature(); data-&gt;humidity = DHT11_Read_Humidity(); data-&gt;light = ADC_Read_Light(); data-&gt;air_quality = ADC_Read_Air(); } é¡¹ç›®2ï¼šæ™ºèƒ½å°è½¦æ§åˆ¶ç³»ç»Ÿ // ç”µæœºæ§åˆ¶ typedef enum { CAR_FORWARD, CAR_BACKWARD, CAR_LEFT, CAR_RIGHT, CAR_STOP } CarDirection; void Car_Control(CarDirection dir, uint8_t speed) { switch(dir) { case CAR_FORWARD: Motor_Control(MOTOR_LEFT, FORWARD, speed); Motor_Control(MOTOR_RIGHT, FORWARD, speed); break; case CAR_BACKWARD: Motor_Control(MOTOR_LEFT, BACKWARD, speed); Motor_Control(MOTOR_RIGHT, BACKWARD, speed); break; // ... å…¶ä»–æ–¹å‘æ§åˆ¶ } } ğŸ”§ è°ƒè¯•æŠ€å·§ 1. ä¸²å£è°ƒè¯• // è°ƒè¯•å®å®šä¹‰ #define DEBUG_PRINTF(fmt, args...) \ do { \ char debug_buf[128]; \ sprintf(debug_buf, fmt, ##args); \ HAL_UART_Transmit(&amp;huart1, (uint8_t*)debug_buf, strlen(debug_buf), 1000); \ } while(0) // ä½¿ç”¨ç¤ºä¾‹ DEBUG_PRINTF(&#34;Temperature: %.2fÂ°C\r\n&#34;, temperature); 2. LEDçŠ¶æ€æŒ‡ç¤º // é”™è¯¯ç æŒ‡ç¤º void Error_Handler(uint32_t error_code) { while(1) { for(int i = 0; i &lt; error_code; i&#43;&#43;) { HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET); HAL_Delay(200); HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET); HAL_Delay(200); } HAL_Delay(1000); } } ğŸ“ˆ å­¦ä¹ æ—¶é—´è§„åˆ’ å‘¨æ•° å­¦ä¹ å†…å®¹ å®è·µé¡¹ç›® é¢„æœŸæˆæœ 1-2 å¼€å‘ç¯å¢ƒæ­å»ºï¼ŒGPIOæ§åˆ¶ LEDé—ªçƒå®éªŒ æŒæ¡åŸºæœ¬GPIOæ“ä½œ 3-4 å®šæ—¶å™¨ï¼ŒPWMï¼Œä¸­æ–­ å‘¼å¸ç¯ï¼ŒæŒ‰é”®æ§åˆ¶ ç†è§£å®šæ—¶å™¨å’Œä¸­æ–­ 5-6 ä¸²å£é€šä¿¡ï¼ŒADC ä¸²å£è°ƒè¯•åŠ©æ‰‹ï¼Œç”µå‹è¡¨ æŒæ¡é€šä¿¡å’Œé‡‡æ · 7-8 I2Cï¼ŒSPIé€šä¿¡ ä¼ æ„Ÿå™¨æ•°æ®è¯»å– ç†Ÿæ‚‰æ€»çº¿é€šä¿¡ 9-10 DMAï¼Œé«˜çº§å®šæ—¶å™¨ éŸ³é¢‘æ’­æ”¾ï¼Œé«˜é€Ÿé‡‡é›† äº†è§£é«˜çº§ç‰¹æ€§ 11-12 FreeRTOSåŸºç¡€ å¤šä»»åŠ¡ç³»ç»Ÿ æŒæ¡å®æ—¶ç³»ç»Ÿ ğŸš€ è¿›é˜¶æ–¹å‘ 1. FreeRTOSå®æ—¶ç³»ç»Ÿ // ä»»åŠ¡åˆ›å»º osThreadId_t defaultTaskHandle; const osThreadAttr_t defaultTask_attributes = { .name = &#34;defaultTask&#34;, .stack_size = 128 * 4, .priority = (osPriority_t) osPriorityNormal, }; defaultTaskHandle = osThreadNew(StartDefaultTask, NULL, &amp;defaultTask_attributes); 2. Bootloaderå¼€å‘ IAP (In-Application Programming) å›ºä»¶å‡çº§æœºåˆ¶ åŒå¤‡ä»½ç³»ç»Ÿ 3. ä½åŠŸè€—ä¼˜åŒ– STOPå’ŒSTANDBYæ¨¡å¼ å¤–è®¾æ—¶é’Ÿç®¡ç† åŠ¨æ€ç”µå‹è°ƒèŠ‚ ğŸ’¡ å¸¸è§é—®é¢˜è§£å†³ Q1: ç¨‹åºä¸‹è½½å¤±è´¥ è§£å†³æ–¹æ¡ˆ:
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-11-08 10:30:00 +0800 CST'>2025-11-08</span>&nbsp;Â·&nbsp;<span>3 min</span>&nbsp;Â·&nbsp;<span>563 words</span>&nbsp;Â·&nbsp;<span>dmk69</span></footer>
  <a class="entry-link" aria-label="post link to STM32å®Œæ•´å­¦ä¹ æŒ‡å—ï¼šä»å…¥é—¨åˆ°ç²¾é€š" href="http://localhost:1313/posts/stm32-learning-guide/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover">
        <img loading="lazy" src="https://images.unsplash.com/photo-1581091226825-a6a2a5aee158?w=800&amp;h=400&amp;fit=crop" alt="æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒ">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒ
    </h2>
  </header>
  <div class="entry-content">
    <p>ğŸ”§ é¡¹ç›®æ¦‚è¿° è¿™æ˜¯ä¸€ä¸ªåŸºäºSTM32F4ç³»åˆ—å¾®æ§åˆ¶å™¨çš„æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒï¼Œä¸“é—¨ç”¨äºå·¥ä¸šç°åœºçš„æ•°æ®é‡‡é›†ã€è®¾å¤‡æ§åˆ¶å’Œæ•°æ®é€šä¿¡ã€‚è¯¥æ§åˆ¶å•å…ƒé›†æˆäº†å¤šç§å·¥ä¸šä¼ æ„Ÿå™¨ï¼Œæ”¯æŒModbus RTU/TCPé€šä¿¡åè®®ï¼Œå¯ä½œä¸ºPLCç³»ç»Ÿçš„è¡¥å……æ§åˆ¶å™¨æˆ–ç‹¬ç«‹çš„ç›‘æ§èŠ‚ç‚¹ä½¿ç”¨ã€‚
ğŸ¯ é¡¹ç›®ç›®æ ‡ å®ç°å¤šä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†å’Œé¢„å¤„ç† æä¾›æœ¬åœ°æ§åˆ¶å’Œä¿æŠ¤åŠŸèƒ½ æ”¯æŒModbuså·¥ä¸šé€šä¿¡åè®® å…·å¤‡æ•°æ®è®°å½•å’Œæ•…éšœè¯Šæ–­èƒ½åŠ› æ»¡è¶³å·¥ä¸šç¯å¢ƒçš„å¯é æ€§è¦æ±‚ ğŸ”§ ç¡¬ä»¶æ¶æ„ STM32æ§åˆ¶æ¿è®¾è®¡ ç¡¬ä»¶é…ç½®: ä¸»æ§åˆ¶å™¨: â”œâ”€â”€ STM32F407VGT6 (ARM Cortex-M4, 168MHz) â”œâ”€â”€ 1MB Flash, 192KB RAM â”œâ”€â”€ 3Ã—UART (é€šä¿¡æ¥å£) â”œâ”€â”€ 2Ã—I2C (ä¼ æ„Ÿå™¨æ‰©å±•) â”œâ”€â”€ 3Ã—SPI (é«˜é€Ÿæ•°æ®æ¥å£) â”œâ”€â”€ 16Ã—12ä½ADC (æ¨¡æ‹Ÿé‡é‡‡é›†) â””â”€â”€ 2Ã—12ä½DAC (æ¨¡æ‹Ÿé‡è¾“å‡º) ç”µæºç®¡ç†: â”œâ”€â”€ 24V DCå·¥ä¸šç”µæºè¾“å…¥ â”œâ”€â”€ 5V/3.3V DC-DCè½¬æ¢å™¨ â”œâ”€â”€ ç”µæºæ»¤æ³¢å’Œä¿æŠ¤ç”µè·¯ â”œâ”€â”€ å¤‡ç”¨ç”µæ±  (RTCå’Œæ•°æ®ä¿æŒ) â””â”€â”€ çœ‹é—¨ç‹—å®šæ—¶å™¨ é€šä¿¡æ¥å£: â”œâ”€â”€ RS485æ¥å£ (Modbus RTU) â”œâ”€â”€ Ethernetæ¥å£ (Modbus TCP) â”œâ”€â”€ USBæ¥å£ (è°ƒè¯•å’Œé…ç½®) â”œâ”€â”€ CANæ€»çº¿æ¥å£ (è®¾å¤‡äº’è”) â””â”€â”€ WiFiæ¨¡å— (å¯é€‰æ— çº¿é€šä¿¡) ä¼ æ„Ÿå™¨æ¥å£ç”µè·¯ ä¼ æ„Ÿå™¨è¿æ¥: â”œâ”€â”€ æ¸©åº¦ä¼ æ„Ÿå™¨ (PT100) â”‚ â”œâ”€â”€ æ’æµæºæ¿€åŠ±ç”µè·¯ â”‚ â”œâ”€â”€ ä¿¡å·æ”¾å¤§å’Œæ»¤æ³¢ â”‚ â””â”€â”€ å†·ç«¯è¡¥å¿ â”œâ”€â”€ å‹åŠ›ä¼ æ„Ÿå™¨ (4-20mA) â”‚ â”œâ”€â”€ ç²¾å¯†ç”µé˜»é‡‡æ · â”‚ â”œâ”€â”€ è¿‡å‹ä¿æŠ¤ â”‚ â””â”€â”€ ä¿¡å·éš”ç¦» â”œâ”€â”€ æµé‡è®¡ (è„‰å†²è¾“å‡º) â”‚ â”œâ”€â”€ å…‰ç”µéš”ç¦»è¾“å…¥ â”‚ â”œâ”€â”€ é¢‘ç‡æµ‹é‡ç”µè·¯ â”‚ â””â”€â”€ æŠ—å¹²æ‰°æ»¤æ³¢ â””â”€â”€ æŒ¯åŠ¨ä¼ æ„Ÿå™¨ (IEPE) â”œâ”€â”€ æ’æµæºä¾›ç”µ â”œâ”€â”€ ACä¿¡å·æ”¾å¤§ â””â”€â”€ RMSè½¬æ¢ç”µè·¯ ğŸ’» è½¯ä»¶æ¶æ„ ä¸»ç¨‹åºæ¡†æ¶ /** * @file main.c * @brief æ™ºèƒ½æ§åˆ¶å•å…ƒä¸»ç¨‹åº * @author Automation Technician * @date 2025-11-12 */ #include &#34;main.h&#34; #include &#34;sensor_manager.h&#34; #include &#34;modbus_server.h&#34; #include &#34;data_logger.h&#34; #include &#34;watchdog.h&#34; #include &#34;system_config.h&#34; /* å…¨å±€å˜é‡å®šä¹‰ */ SystemStatus_t g_systemStatus; SensorData_t g_sensorData; ModbusRegisters_t g_modbusRegisters; uint32_t g_systemTick = 0; /* å‡½æ•°å£°æ˜ */ static void SystemClock_Config(void); static void GPIO_Init(void); static void Peripherals_Init(void); static void Task_SensorAcquisition(void); static void Task_DataProcessing(void); static void Task_Communication(void); static void Task_SystemMonitoring(void); /** * @brief ä¸»å‡½æ•° */ int main(void) { /* ç³»ç»Ÿåˆå§‹åŒ– */ HAL_Init(); SystemClock_Config(); GPIO_Init(); Peripherals_Init(); /* å¤–è®¾åˆå§‹åŒ– */ SensorManager_Init(); ModbusServer_Init(); DataLogger_Init(); Watchdog_Init(); /* ç³»ç»ŸçŠ¶æ€åˆå§‹åŒ– */ g_systemStatus.mode = MODE_AUTO; g_systemStatus.error_code = ERROR_NONE; g_systemStatus.uptime = 0; /* ä¸»å¾ªç¯ */ while (1) { g_systemTick = HAL_GetTick(); /* ä»»åŠ¡è°ƒåº¦ */ Task_SensorAcquisition(); // 100mså‘¨æœŸ Task_DataProcessing(); // 500mså‘¨æœŸ Task_Communication(); // å®æ—¶å¤„ç† Task_SystemMonitoring(); // 1000mså‘¨æœŸ /* å–‚ç‹— */ Watchdog_Refresh(); /* ä½åŠŸè€—å¤„ç† */ if (g_systemStatus.mode == MODE_SLEEP) { __WFI(); } } } /** * @brief ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†ä»»åŠ¡ */ static void Task_SensorAcquisition(void) { static uint32_t lastAcquisitionTime = 0; /* 100msé‡‡é›†å‘¨æœŸ */ if (g_systemTick - lastAcquisitionTime &gt;= 100) { /* é‡‡é›†æ¸©åº¦æ•°æ® */ g_sensorData.temperature = SensorManager_ReadTemperature(); /* é‡‡é›†å‹åŠ›æ•°æ® */ g_sensorData.pressure = SensorManager_ReadPressure(); /* é‡‡é›†æµé‡æ•°æ® */ g_sensorData.flow_rate = SensorManager_ReadFlowRate(); /* é‡‡é›†æŒ¯åŠ¨æ•°æ® */ g_sensorData.vibration = SensorManager_ReadVibration(); /* æ›´æ–°æ•°æ®æ—¶é—´æˆ³ */ g_sensorData.timestamp = g_systemTick; lastAcquisitionTime = g_systemTick; } } /** * @brief æ•°æ®å¤„ç†ä»»åŠ¡ */ static void Task_DataProcessing(void) { static uint32_t lastProcessingTime = 0; /* 500mså¤„ç†å‘¨æœŸ */ if (g_systemTick - lastProcessingTime &gt;= 500) { /* æ•°æ®æ»¤æ³¢å¤„ç† */ DataLogger_FilterSensorData(&amp;g_sensorData); /* æ•°æ®èŒƒå›´æ£€æŸ¥ */ DataLogger_ValidateSensorData(&amp;g_sensorData); /* è®¡ç®—è¡ç”Ÿå‚æ•° */ g_sensorData.pressure_rate = DataLogger_CalculatePressureRate(); g_sensorData.flow_total = DataLogger_CalculateFlowTotal(); /* æ›´æ–°Modbuså¯„å­˜å™¨ */ ModbusServer_UpdateRegisters(&amp;g_sensorData); lastProcessingTime = g_systemTick; } } /** * @brief é€šä¿¡å¤„ç†ä»»åŠ¡ */ static void Task_Communication(void) { /* Modbus RTUé€šä¿¡å¤„ç† */ if (HAL_UART_GetState(&amp;huart1) == HAL_UART_STATE_BUSY_RX) { ModbusServer_ProcessRTU(); } /* Modbus TCPé€šä¿¡å¤„ç† */ if (HAL_ETH_GetState(&amp;heth) == HAL_ETH_STATE_BUSY_RX) { ModbusServer_ProcessTCP(); } /* USBé€šä¿¡å¤„ç† (è°ƒè¯•ç”¨) */ if (HAL_UART_GetState(&amp;huart3) == HAL_UART_STATE_BUSY_RX) { ProcessUSBCommand(); } } /** * @brief ç³»ç»Ÿç›‘æ§ä»»åŠ¡ */ static void Task_SystemMonitoring(void) { static uint32_t lastMonitorTime = 0; /* 1000msç›‘æ§å‘¨æœŸ */ if (g_systemTick - lastMonitorTime &gt;= 1000) { /* æ›´æ–°ç³»ç»Ÿè¿è¡Œæ—¶é—´ */ g_systemStatus.uptime&#43;&#43;; /* æ£€æŸ¥ç³»ç»Ÿé”™è¯¯ */ SystemError_Check(); /* ç›‘æ§ç”µæºç”µå‹ */ if (SystemMonitor_GetPowerVoltage() &lt; 20.0) { g_systemStatus.error_code |= ERROR_LOW_VOLTAGE; } /* æ£€æŸ¥å­˜å‚¨ç©ºé—´ */ if (DataLogger_GetFreeSpace() &lt; 1024) { g_systemStatus.error_code |= ERROR_STORAGE_FULL; } /* ç³»ç»ŸçŠ¶æ€LEDæŒ‡ç¤º */ SystemStatus_UpdateLED(); lastMonitorTime = g_systemTick; } } ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å— /** * @file sensor_manager.c * @brief ä¼ æ„Ÿå™¨ç®¡ç†æ¨¡å— */ #include &#34;sensor_manager.h&#34; #include &#34;adc.h&#34; #include &#34;tim.h&#34; #include &#34;i2c.h&#34; /* ä¼ æ„Ÿå™¨æ ¡å‡†å‚æ•° */ typedef struct { float offset; float scale; float filter_coefficient; } SensorCalibration_t; static SensorCalibration_t tempCalib = {0.0, 1.0, 0.1}; static SensorCalibration_t pressureCalib = {0.0, 1.0, 0.1}; /** * @brief æ¸©åº¦ä¼ æ„Ÿå™¨è¯»å– (PT100) */ float SensorManager_ReadTemperature(void) { static float filteredTemp = 25.0; uint16_t adcValue; float voltage, resistance, temperature; /* è¯»å–ADCå€¼ */ adcValue = ADC_ReadChannel(ADC_CHANNEL_TEMP); /* è½¬æ¢ä¸ºç”µå‹ */ voltage = (float)adcValue * 3.3f / 4096.0f; /* è®¡ç®—PT100ç”µé˜» */ resistance = voltage * 1000.0f / 1.0f; /* 1mAæ’æµæº */ /* PT100ç”µé˜»-æ¸©åº¦è½¬æ¢ (Callendar-Van Dusenæ–¹ç¨‹) */ if (resistance &gt;= 100.0) { temperature = -242.02 &#43; 2.2228 * resistance &#43; 0.00258 * resistance * resistance; } else { temperature = -242.02 &#43; 2.2228 * resistance; } /* åº”ç”¨æ ¡å‡†å‚æ•° */ temperature = temperature * tempCalib.scale &#43; tempCalib.offset; /* è½¯ä»¶æ»¤æ³¢ */ filteredTemp = filteredTemp * (1.0 - tempCalib.filter_coefficient) &#43; temperature * tempCalib.filter_coefficient; return filteredTemp; } /** * @brief å‹åŠ›ä¼ æ„Ÿå™¨è¯»å– (4-20mA) */ float SensorManager_ReadPressure(void) { static float filteredPressure = 0.0; uint16_t adcValue; float current, pressure; /* è¯»å–ADCå€¼ */ adcValue = ADC_ReadChannel(ADC_CHANNEL_PRESSURE); /* è½¬æ¢ä¸ºç”µæµ (4-20mAå¯¹åº”0.8-4Vç”µå‹) */ float voltage = (float)adcValue * 3.3f / 4096.0f; current = (voltage - 0.8f) * 5.0f; /* 4-20mA */ /* è½¬æ¢ä¸ºå‹åŠ›å€¼ (0-10Bar) */ pressure = (current - 4.0f) * 10.0f / 16.0f; /* 4-20mA -&gt; 0-10Bar */ /* è´Ÿå€¼å¤„ç† */ if (pressure &lt; 0.0) pressure = 0.0; /* åº”ç”¨æ ¡å‡†å‚æ•° */ pressure = pressure * pressureCalib.scale &#43; pressureCalib.offset; /* è½¯ä»¶æ»¤æ³¢ */ filteredPressure = filteredPressure * (1.0 - pressureCalib.filter_coefficient) &#43; pressure * pressureCalib.filter_coefficient; return filteredPressure; } /** * @brief æµé‡ä¼ æ„Ÿå™¨è¯»å– (è„‰å†²è¾“å‡º) */ float SensorManager_ReadFlowRate(void) { static uint32_t lastPulseCount = 0; static uint32_t lastReadTime = 0; static float flowRate = 0.0; uint32_t currentPulseCount, pulseDelta; uint32_t timeDelta; float frequency; /* è·å–å½“å‰è„‰å†²è®¡æ•° */ currentPulseCount = TIM_GetPulseCount(TIM_FLOW); /* è®¡ç®—æ—¶é—´å·® */ timeDelta = g_systemTick - lastReadTime; if (timeDelta &gt; 0) { /* è®¡ç®—è„‰å†²å¢é‡ */ pulseDelta = currentPulseCount - lastPulseCount; /* è®¡ç®—é¢‘ç‡ (Hz) */ frequency = (float)pulseDelta * 1000.0f / (float)timeDelta; /* è½¬æ¢ä¸ºæµé‡ (L/min) */ flowRate = frequency * 60.0f / 100.0f; /* 100è„‰å†²/L */ /* æ›´æ–°å†å²è®°å½• */ lastPulseCount = currentPulseCount; lastReadTime = g_systemTick; } return flowRate; } /** * @brief æŒ¯åŠ¨ä¼ æ„Ÿå™¨è¯»å– (IEPE) */ float SensorManager_ReadVibration(void) { uint16_t adcValue; float voltage, rmsValue; /* è¯»å–ADCå€¼ */ adcValue = ADC_ReadChannel(ADC_CHANNEL_VIBRATION); /* è½¬æ¢ä¸ºç”µå‹ */ voltage = (float)adcValue * 3.3f / 4096.0f; /* è®¡ç®—RMSå€¼ */ rmsValue = Vibration_CalculateRMS(voltage); /* è½¬æ¢ä¸ºåŠ é€Ÿåº¦å€¼ (g) */ float acceleration = rmsValue * 10.0f; /* 10g/Vçµæ•åº¦ */ return acceleration; } Modbusé€šä¿¡æ¨¡å— /** * @file modbus_server.c * @brief ModbusæœåŠ¡å™¨å®ç° */ #include &#34;modbus_server.h&#34; #include &#34;usart.h&#34; #include &#34;ethernet.h&#34; /* Modbuså¯„å­˜å™¨æ˜ å°„ */ typedef union { struct { uint16_t holding_registers[100]; uint16_t input_registers[100]; uint16_t coils[100]; uint16_t discrete_inputs[100]; } registers; uint16_t raw[400]; } ModbusMemoryMap_t; static ModbusMemoryMap_t g_modbusMemory; /** * @brief Modbuså¯„å­˜å™¨æ˜ å°„ */ void ModbusServer_UpdateRegisters(SensorData_t* sensorData) { /* è¾“å…¥å¯„å­˜å™¨ (åªè¯») */ g_modbusMemory.registers.input_registers[0] = (uint16_t)(sensorData-&gt;temperature * 10.0); // æ¸©åº¦ (0.1Â°C) g_modbusMemory.registers.input_registers[1] = (uint16_t)(sensorData-&gt;pressure * 100.0); // å‹åŠ› (0.01Bar) g_modbusMemory.registers.input_registers[2] = (uint16_t)(sensorData-&gt;flow_rate * 10.0); // æµé‡ (0.1L/min) g_modbusMemory.registers.input_registers[3] = (uint16_t)(sensorData-&gt;vibration * 100.0); // æŒ¯åŠ¨ (0.01g) /* ä¿æŒå¯„å­˜å™¨ (è¯»å†™) */ g_modbusMemory.registers.holding_registers[0] = (uint16_t)(g_systemStatus.mode); // è¿è¡Œæ¨¡å¼ g_modbusMemory.registers.holding_registers[1] = (uint16_t)(g_systemStatus.error_code); // é”™è¯¯ä»£ç  g_modbusMemory.registers.holding_registers[2] = (uint16_t)(g_systemStatus.uptime); // è¿è¡Œæ—¶é—´ } /** * @brief å¤„ç†Modbus RTUè¯·æ±‚ */ void ModbusServer_ProcessRTU(void) { static uint8_t rxBuffer[256]; static uint8_t txBuffer[256]; uint16_t rxLength, txLength; /* æ¥æ”¶æ•°æ® */ if (UART_ReceiveBuffer(&amp;huart1, rxBuffer, &amp;rxLength)) { /* è§£æModbusè¯·æ±‚ */ ModbusRequest_t request; if (Modbus_ParseRequest(rxBuffer, rxLength, &amp;request)) { /* å¤„ç†è¯·æ±‚ */ ModbusResponse_t response; Modbus_ProcessRequest(&amp;request, &amp;response); /* ç”Ÿæˆå“åº”å¸§ */ txLength = Modbus_GenerateResponse(&amp;response, txBuffer); /* å‘é€å“åº” */ UART_Transmit(&amp;huart1, txBuffer, txLength); } } } /** * @brief å¤„ç†Modbus TCPè¯·æ±‚ */ void ModbusServer_ProcessTCP(void) { /* TCPé€šä¿¡å¤„ç† (ç®€åŒ–å®ç°) */ uint8_t tcpBuffer[512]; uint16_t tcpLength; if (Ethernet_ReceiveData(tcpBuffer, &amp;tcpLength)) { /* è§£æMBAPå¤´éƒ¨å’ŒModbus PDU */ ModbusTCP_Request_t tcpRequest; if (ModbusTCP_ParseRequest(tcpBuffer, tcpLength, &amp;tcpRequest)) { /* å¤„ç†Modbusè¯·æ±‚ */ ModbusResponse_t response; Modbus_ProcessRequest(&amp;tcpRequest.modbus_request, &amp;response); /* ç”ŸæˆTCPå“åº” */ uint16_t responseLength; responseLength = ModbusTCP_GenerateResponse( &amp;tcpRequest, &amp;response, tcpBuffer); /* å‘é€TCPå“åº” */ Ethernet_TransmitData(tcpBuffer, responseLength); } } } /** * @brief å¤„ç†ModbusåŠŸèƒ½ç  */ void Modbus_ProcessRequest(ModbusRequest_t* request, ModbusResponse_t* response) { response-&gt;slave_address = request-&gt;slave_address; response-&gt;function_code = request-&gt;function_code; switch (request-&gt;function_code) { case MODBUS_FC_READ_HOLDING_REGISTERS: Modbus_ReadHoldingRegisters(request, response); break; case MODBUS_FC_READ_INPUT_REGISTERS: Modbus_ReadInputRegisters(request, response); break; case MODBUS_FC_WRITE_SINGLE_REGISTER: Modbus_WriteSingleRegister(request, response); break; case MODBUS_FC_WRITE_MULTIPLE_REGISTERS: Modbus_WriteMultipleRegisters(request, response); break; default: response-&gt;function_code |= 0x80; // å¼‚å¸¸å“åº” response-&gt;data[0] = MODBUS_EXCEPTION_ILLEGAL_FUNCTION; response-&gt;data_length = 1; break; } } ğŸ“Š æ•°æ®è®°å½•ä¸åˆ†æ æ•°æ®è®°å½•åŠŸèƒ½ /** * @file data_logger.c * @brief æ•°æ®è®°å½•æ¨¡å— */ #include &#34;data_logger.h&#34; #include &#34;flash.h&#34; #include &#34;rtc.h&#34; /* æ•°æ®è®°å½•ç»“æ„ */ typedef struct { uint32_t timestamp; float temperature; float pressure; float flow_rate; float vibration; uint16_t system_status; } DataRecord_t; /* å†å²æ•°æ®ç¼“å†²åŒº */ #define DATA_BUFFER_SIZE 1000 static DataRecord_t g_dataBuffer[DATA_BUFFER_SIZE]; static uint16_t g_dataBufferIndex = 0; static uint32_t g_totalRecords = 0; /** * @brief è®°å½•ä¼ æ„Ÿå™¨æ•°æ® */ void DataLogger_RecordData(SensorData_t* sensorData) { DataRecord_t* record = &amp;g_dataBuffer[g_dataBufferIndex]; /* å¡«å……æ•°æ®è®°å½• */ record-&gt;timestamp = RTC_GetTimestamp(); record-&gt;temperature = sensorData-&gt;temperature; record-&gt;pressure = sensorData-&gt;pressure; record-&gt;flow_rate = sensorData-&gt;flow_rate; record-&gt;vibration = sensorData-&gt;vibration; record-&gt;system_status = g_systemStatus.error_code; /* æ›´æ–°ç¼“å†²åŒºç´¢å¼• */ g_dataBufferIndex = (g_dataBufferIndex &#43; 1) % DATA_BUFFER_SIZE; g_totalRecords&#43;&#43;; /* æ£€æŸ¥æ˜¯å¦éœ€è¦ä¿å­˜åˆ°Flash */ if (g_dataBufferIndex % 100 == 0) { DataLogger_SaveToFlash(); } } /** * @brief æ•°æ®æ»¤æ³¢å¤„ç† */ void DataLogger_FilterSensorData(SensorData_t* sensorData) { static SensorData_t filterBuffer[5]; static uint8_t filterIndex = 0; /* æ›´æ–°æ»¤æ³¢ç¼“å†²åŒº */ filterBuffer[filterIndex] = *sensorData; filterIndex = (filterIndex &#43; 1) % 5; /* è®¡ç®—ç§»åŠ¨å¹³å‡å€¼ */ float tempSum = 0.0, pressureSum = 0.0; float flowSum = 0.0, vibrationSum = 0.0; for (int i = 0; i &lt; 5; i&#43;&#43;) { tempSum &#43;= filterBuffer[i].temperature; pressureSum &#43;= filterBuffer[i].pressure; flowSum &#43;= filterBuffer[i].flow_rate; vibrationSum &#43;= filterBuffer[i].vibration; } sensorData-&gt;temperature = tempSum / 5.0; sensorData-&gt;pressure = pressureSum / 5.0; sensorData-&gt;flow_rate = flowSum / 5.0; sensorData-&gt;vibration = vibrationSum / 5.0; } /** * @brief æ•°æ®æœ‰æ•ˆæ€§æ£€æŸ¥ */ bool DataLogger_ValidateSensorData(SensorData_t* sensorData) { bool isValid = true; /* æ¸©åº¦èŒƒå›´æ£€æŸ¥ */ if (sensorData-&gt;temperature &lt; -40.0 || sensorData-&gt;temperature &gt; 125.0) { sensorData-&gt;temperature = 25.0; // é»˜è®¤å€¼ isValid = false; } /* å‹åŠ›èŒƒå›´æ£€æŸ¥ */ if (sensorData-&gt;pressure &lt; 0.0 || sensorData-&gt;pressure &gt; 20.0) { sensorData-&gt;pressure = 0.0; isValid = false; } /* æµé‡èŒƒå›´æ£€æŸ¥ */ if (sensorData-&gt;flow_rate &lt; 0.0 || sensorData-&gt;flow_rate &gt; 1000.0) { sensorData-&gt;flow_rate = 0.0; isValid = false; } /* æŒ¯åŠ¨èŒƒå›´æ£€æŸ¥ */ if (sensorData-&gt;vibration &lt; 0.0 || sensorData-&gt;vibration &gt; 50.0) { sensorData-&gt;vibration = 0.0; isValid = false; } return isValid; } ğŸ”§ ç³»ç»Ÿæµ‹è¯•ä¸éªŒè¯ åŠŸèƒ½æµ‹è¯•æ¸…å• ç¡¬ä»¶æµ‹è¯•: âœ“ ç”µæºè¾“å…¥æµ‹è¯• (24V DC Â±10%) âœ“ å·¥ä½œæ¸©åº¦æµ‹è¯• (-20Â°C ~ &#43;70Â°C) âœ“ EMIæŠ—å¹²æ‰°æµ‹è¯• (IEC 61000-4-3) âœ“ é˜²æŠ¤ç­‰çº§æµ‹è¯• (IP65) âœ“ æŒ¯åŠ¨æµ‹è¯• (IEC 60068-2-6) è½¯ä»¶æµ‹è¯•: âœ“ ä¼ æ„Ÿå™¨ç²¾åº¦æµ‹è¯• (Â±0.1%) âœ“ Modbusé€šä¿¡æµ‹è¯• (RTU/TCP) âœ“ æ•°æ®è®°å½•æµ‹è¯• (1000æ¡/ç§’) âœ“ çœ‹é—¨ç‹—åŠŸèƒ½æµ‹è¯• âœ“ æ•…éšœæ¢å¤æµ‹è¯• æ€§èƒ½æŒ‡æ ‡: âœ“ å¯åŠ¨æ—¶é—´: &lt; 2ç§’ âœ“ æ•°æ®æ›´æ–°é¢‘ç‡: 10Hz âœ“ é€šä¿¡å“åº”æ—¶é—´: &lt; 100ms âœ“ å­˜å‚¨å®¹é‡: 10,000æ¡è®°å½• âœ“ åŠŸè€—: &lt; 5W ç°åœºæµ‹è¯•ç»“æœ æµ‹è¯•ç¯å¢ƒ: å·¥ä¸šæ³µç«™ç°åœº æµ‹è¯•æ—¶é—´: 72å°æ—¶è¿ç»­è¿è¡Œ ä¼ æ„Ÿå™¨æµ‹è¯•ç»“æœ: - æ¸©åº¦æµ‹é‡ç²¾åº¦: Â±0.05Â°C (PT100, 0-100Â°CèŒƒå›´) - å‹åŠ›æµ‹é‡ç²¾åº¦: Â±0.2%FS (4-20mA, 0-10Bar) - æµé‡æµ‹é‡ç²¾åº¦: Â±1.0% (è„‰å†²è¾“å‡º, 0-500L/min) - æŒ¯åŠ¨æµ‹é‡ç²¾åº¦: Â±5% (IEPE, 0-10g) é€šä¿¡æµ‹è¯•ç»“æœ: - Modbus RTU: 9600bps, 0é”™è¯¯ - Modbus TCP: 100Mbps, &lt;10mså»¶è¿Ÿ - æ•°æ®å®Œæ•´æ€§: 99.99% - è¿æ¥ç¨³å®šæ€§: 72å°æ—¶æ— æ–­çº¿ ç³»ç»Ÿç¨³å®šæ€§: - è¿ç»­è¿è¡Œæ—¶é—´: 72å°æ—¶ - å†…å­˜ä½¿ç”¨ç‡: 45% - CPUä½¿ç”¨ç‡: 30% - å­˜å‚¨ç©ºé—´ä½¿ç”¨: 23% ğŸ“ˆ é¡¹ç›®åº”ç”¨åœºæ™¯ å·¥ä¸šåº”ç”¨æ¡ˆä¾‹ æ³µç«™ç›‘æ§ç³»ç»Ÿ
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-11-12 12:00:00 +0800 CST'>2025-11-12</span>&nbsp;Â·&nbsp;<span>8 min</span>&nbsp;Â·&nbsp;<span>1603 words</span>&nbsp;Â·&nbsp;<span>dmk69</span></footer>
  <a class="entry-link" aria-label="post link to æ™ºèƒ½è®¾å¤‡æ§åˆ¶å•å…ƒ" href="http://localhost:1313/projects/embedded-control-unit/"></a>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Automation &amp; Industrial Control Technician</a></span> Â· 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
